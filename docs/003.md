# 003 - 微博登录功能开发方案

## 一、功能概述

在 `@pro/admin` 中实现微博扫码登录功能，通过 Playwright 自动化控制浏览器获取二维码，并使用 SSE (Server-Sent Events) 实时推送登录状态变化。**登录成功后获取并保存微博 Cookie 到数据库，供后续爬虫使用。支持一个用户绑定多个微博账号。**

## 二、技术架构

### 2.1 后端 (@pro/api)
- **Playwright**: 无头浏览器控制，访问微博登录页面
- **SSE**: 服务端推送登录状态变化
- **Response 监控**: 拦截并解析二维码生成和状态检查接口

### 2.2 前端 (@pro/admin)
- **EventSource**: 接收 SSE 推送的登录状态
- **二维码展示**: 显示微博登录二维码
- **状态处理**: 处理扫码成功/拒绝/过期等状态

## 三、核心流程

### 3.1 二维码获取流程
1. 前端请求后端启动微博登录
2. 后端使用 Playwright 打开微博登录页面
3. 监控二维码生成接口: `https://passport.weibo.com/sso/v2/qrcode/image`
4. 解析响应获取 `qrid` 和 `image`
5. 通过 SSE 推送二维码信息给前端

### 3.2 状态监控流程
1. 监控状态检查接口: `https://passport.weibo.com/sso/v2/qrcode/check`
2. 轮询获取二维码状态变化
3. 通过 SSE 实时推送状态:
   - `50114001`: 未使用（等待扫码）
   - `50114002`: 成功扫描，等待手机确认
   - `50114003`: 二维码已过期
   - 其他状态码: 用户拒绝等异常情况
4. 监控页面导航事件:
   - 当页面跳转到 `https://weibo.com/` 时，表示登录成功
   - 此时 check 接口响应为空
5. 登录成功后:
   - 获取浏览器上下文的所有 Cookie
   - 提取微博用户信息（uid、昵称等）
   - 保存到数据库关联到当前用户
6. 二维码过期后:
   - 推送过期事件给前端
   - 前端可选择重新发起登录
7. 关闭浏览器页面和上下文

## 四、数据库设计

### 4.1 微博账号表 (weibo_accounts)
```sql
CREATE TABLE weibo_accounts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,                    -- 关联用户 ID
  weibo_uid VARCHAR(50) NOT NULL,              -- 微博 UID (idstr)
  weibo_nickname VARCHAR(100),                  -- 微博昵称 (screen_name)
  weibo_avatar VARCHAR(500),                    -- 微博头像 URL (avatar_hd)
  cookies TEXT NOT NULL,                        -- Cookie JSON 字符串
  status VARCHAR(20) DEFAULT 'active',          -- 账号状态: active/expired/banned
  last_check_at TIMESTAMP,                      -- 最后检查时间
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, weibo_uid),                   -- 同一用户不能重复绑定同一微博账号
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_weibo_accounts_user_id ON weibo_accounts(user_id);
CREATE INDEX idx_weibo_accounts_status ON weibo_accounts(status);
```

## 五、接口设计

### 5.1 启动微博登录
```
GET /api/weibo/login/start
Headers: Authorization: Bearer <token>
Response: SSE Stream
```

### 5.2 SSE 事件类型
```typescript
// 二维码生成事件
{
  type: 'qrcode',
  data: {
    qrid: string,
    image: string
  }
}

// 状态变化事件
{
  type: 'status',
  data: {
    retcode: number,
    msg: string,
    data: any
  }
}

// 已扫码事件（等待确认）
{
  type: 'scanned',
  data: {
    message: '成功扫描，请在手机点击确认以登录'
  }
}

// 成功事件（Cookie 已保存）
{
  type: 'success',
  data: {
    accountId: number,
    weiboUid: string,
    weiboNickname: string,
    weiboAvatar: string
  }
}

// 过期事件
{
  type: 'expired',
  data: {
    message: '该二维码已过期，请重新扫描'
  }
}

// 错误事件
{
  type: 'error',
  data: {
    message: string
  }
}
```

### 5.3 获取微博账号列表
```
GET /api/weibo/accounts
Headers: Authorization: Bearer <token>
Response: {
  accounts: [
    {
      id: number,
      weiboUid: string,
      weiboNickname: string,
      weiboAvatar: string,
      status: string,
      lastCheckAt: string,
      createdAt: string
    }
  ]
}
```

### 5.4 删除微博账号
```
DELETE /api/weibo/accounts/:id
Headers: Authorization: Bearer <token>
Response: { success: boolean }
```

## 六、任务拆分

### 任务 A: 数据库表设计 (@pro/api)
- [ ] 创建 weibo_accounts 表 migration
- [ ] 创建 WeiboAccount Entity
- [ ] 创建 WeiboAccountRepository

### 任务 B: 后端基础设施 (@pro/api)
- [ ] 安装 Playwright 依赖
- [ ] 配置 Playwright 环境
- [ ] 创建 Weibo Module

### 任务 C: 微博登录服务实现 (@pro/api)
依赖: 任务 A, B
- [ ] 创建 WeiboAuthService
- [ ] 实现 Playwright 浏览器启动和页面控制
- [ ] 实现 Response 监控逻辑
- [ ] 实现二维码获取和状态轮询
- [ ] 实现 Cookie 提取和保存逻辑
- [ ] 实现微博用户信息提取

### 任务 D: SSE 推送实现 (@pro/api)
依赖: 任务 B
- [ ] 创建 WeiboController (SSE 端点)
- [ ] 实现事件流推送机制
- [ ] 实现连接管理和清理

### 任务 E: 账号管理接口 (@pro/api)
依赖: 任务 A
- [ ] 实现获取账号列表接口
- [ ] 实现删除账号接口
- [ ] 实现账号状态更新逻辑
- [ ] 添加权限验证（用户只能操作自己的账号）

### 任务 F: SDK 接口封装 (@pro/sdk)
- [ ] 定义微博相关的 TypeScript 接口类型
- [ ] 封装微博登录 SSE 连接方法
- [ ] 封装获取账号列表接口
- [ ] 封装删除账号接口
- [ ] 导出所有微博相关接口

### 任务 G: 前端登录组件 (@pro/admin)
依赖: 任务 F
- [ ] 创建微博登录页面/弹窗组件（使用 Tailwind CSS）
- [ ] 使用 SDK 的 SSE 连接方法
- [ ] 实现二维码展示（Tailwind 样式）
- [ ] 实现状态显示和处理（Tailwind 样式）
- [ ] 处理登录成功后的反馈

### 任务 H: 前端账号管理 (@pro/admin)
依赖: 任务 F
- [ ] 创建微博账号列表组件（使用 Tailwind CSS）
- [ ] 使用 SDK 获取账号列表
- [ ] 使用 SDK 删除账号
- [ ] 实现账号状态显示（Tailwind 样式）

### 任务 I: 集成测试
依赖: 任务 C, D, E, F, G, H
- [ ] 测试二维码生成
- [ ] 测试状态推送
- [ ] 测试扫码成功和 Cookie 保存
- [ ] 测试多账号绑定
- [ ] 测试账号列表和删除
- [ ] 测试超时和异常处理

## 七、执行顺序

```
A (数据库设计) | B (后端基础设施)
      ↓               ↓
      ↓         C (微博登录服务) | D (SSE 推送)
      ↓               ↓                ↓
E (账号管理接口) ←────┴────────────────┘
      ↓
      F (SDK 接口封装)
      ↓
G (前端登录组件) | H (前端账号管理)
      ↘              ↙
         I (集成测试)
```

**执行说明**:
1. A 和 B 并行执行（数据库设计 | 后端基础设施）
2. A、B 完成后，C 和 D 并行执行（微博登录服务 | SSE 推送）
3. A 完成后可以执行 E（账号管理接口）
4. 后端接口（C、D、E）完成后，执行 F（SDK 接口封装）
5. F 完成后，G 和 H 并行执行（前端登录组件 | 前端账号管理）
6. 所有功能完成后执行 I（集成测试）

## 八、技术细节

### 8.1 Playwright Response 监控和页面导航监控
```typescript
// WeiboAuthService
async startLogin(userId: number): Promise<Observable<MessageEvent>> {
  const context = await this.browser.newContext();
  const page = await context.newPage();

  let qrid: string;

  // 监听二维码生成和状态检查
  page.on('response', async (response) => {
    const url = response.url();

    if (url.includes('qrcode/image')) {
      const data = await response.json();
      qrid = data.data.qrid;
      // 推送二维码事件
      this.emit('qrcode', { qrid, image: data.data.image });
    }

    if (url.includes('qrcode/check')) {
      try {
        const data = await response.json();
        // 推送状态变化事件
        this.emit('status', data);

        if (data.retcode === 50114002) {
          // 已扫码，等待确认
          this.emit('scanned', { message: data.msg });
        } else if (data.retcode === 50114003) {
          // 二维码过期
          this.emit('expired', { message: data.msg });
          await context.close();
        }
      } catch (e) {
        // 响应为空或无法解析，可能是登录成功后的空响应
        console.log('Check response empty or invalid');
      }
    }
  });

  // 监听页面导航 - 登录成功的关键
  page.on('framenavigated', async (frame) => {
    if (frame === page.mainFrame()) {
      const url = frame.url();

      if (url.startsWith('https://weibo.com/')) {
        // 登录成功，页面跳转到微博首页
        const cookies = await context.cookies();
        const userInfo = await this.extractUserInfo(page);
        const account = await this.saveAccount(userId, cookies, userInfo);

        this.emit('success', {
          accountId: account.id,
          weiboUid: account.weiboUid,
          weiboNickname: account.weiboNickname,
          weiboAvatar: account.weiboAvatar
        });

        await context.close();
      }
    }
  });

  await page.goto('https://passport.weibo.com/sso/signin?entry=miniblog&source=miniblog&disp=popup&url=https%3A%2F%2Fweibo.com%2Fnewlogin%3Ftabtype%3Dweibo%26gid%3D102803%26openLoginLayer%3D0%26url%3Dhttps%253A%252F%252Fweibo.com%252F&from=weibopro');

  return this.asObservable();
}
```

### 8.2 Cookie 提取和保存
```typescript
// 提取所有 Cookie
const cookies = await context.cookies();

// 提取微博用户信息（从页面全局变量）
async extractUserInfo(page: Page) {
  // 从微博页面的全局变量 window.$CONFIG.user 获取用户信息
  // window.$CONFIG.user 结构:
  // {
  //   id: 5286244471,
  //   idstr: "5286244471",
  //   screen_name: "二倍体97851",
  //   avatar_hd: "https://tvax1.sinaimg.cn/default/images/default_avatar_male_180.gif?..."
  // }
  const userInfo = await page.evaluate(() => {
    return {
      id: window.$CONFIG?.user?.id,
      idstr: window.$CONFIG?.user?.idstr,
      screen_name: window.$CONFIG?.user?.screen_name,
      avatar_hd: window.$CONFIG?.user?.avatar_hd
    };
  });

  if (!userInfo.id) {
    throw new Error('Failed to extract user info from window.$CONFIG.user');
  }

  return {
    uid: userInfo.idstr || userInfo.id.toString(),
    nickname: userInfo.screen_name || `微博用户_${userInfo.idstr}`,
    avatar: userInfo.avatar_hd || ''
  };
}

// 保存到数据库
async saveAccount(userId: number, cookies: Cookie[], userInfo: any) {
  const account = await this.weiboAccountRepo.save({
    userId,
    weiboUid: userInfo.uid,
    weiboNickname: userInfo.nickname,
    weiboAvatar: userInfo.avatar,
    cookies: JSON.stringify(cookies),
    status: 'active'
  });

  return account;
}
```

### 8.3 SSE 实现 (NestJS)
```typescript
@Controller('weibo')
export class WeiboController {
  @Get('login/start')
  @UseGuards(JwtAuthGuard)
  @Sse()
  async startLogin(@Request() req): Promise<Observable<MessageEvent>> {
    const userId = req.user.id;
    return this.weiboAuthService.startLogin(userId);
  }
}
```

### 8.4 前端使用 SDK (@pro/admin) - Tailwind CSS
```typescript
// apps/admin/src/app/features/weibo/weibo-login.component.ts
import { Component } from '@angular/core';
import { createWeiboAuthSDK, WeiboLoginEvent } from '@pro/sdk';
import { AuthService } from '../../core/services/auth.service';

@Component({
  selector: 'app-weibo-login',
  template: `
    <div class="max-w-md mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h2 class="text-2xl font-bold text-gray-800 mb-6">微博账号登录</h2>

      <div *ngIf="qrcodeUrl" class="flex flex-col items-center space-y-4">
        <div class="p-4 bg-gray-50 rounded-lg">
          <img [src]="qrcodeUrl" alt="微博登录二维码"
               class="w-48 h-48 object-contain">
        </div>
        <p class="text-sm text-gray-600">{{ status }}</p>
      </div>

      <button
        (click)="startWeiboLogin()"
        [disabled]="isLoading"
        class="w-full mt-6 px-4 py-2 bg-blue-600 text-white rounded-lg
               hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed
               transition-colors duration-200">
        {{ isLoading ? '登录中...' : '开始微博登录' }}
      </button>

      <!-- 状态指示器 -->
      <div *ngIf="isLoading" class="mt-4 flex items-center justify-center space-x-2">
        <div class="w-2 h-2 bg-blue-600 rounded-full animate-bounce"></div>
        <div class="w-2 h-2 bg-blue-600 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
        <div class="w-2 h-2 bg-blue-600 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
      </div>
    </div>
  `
})
export class WeiboLoginComponent {
  qrcodeUrl: string = '';
  status: string = '';
  isLoading: boolean = false;

  private weiboSDK = createWeiboAuthSDK(this.getApiUrl());

  constructor(private authService: AuthService) {}

  private getApiUrl(): string {
    return 'http://localhost:3000'; // 或从环境变量读取
  }

  startWeiboLogin() {
    this.isLoading = true;
    const token = this.authService.getToken();

    this.weiboSDK.startLogin(token, (event: WeiboLoginEvent) => {
      switch(event.type) {
        case 'qrcode':
          this.qrcodeUrl = event.data.image;
          this.status = '等待扫码...';
          break;
        case 'scanned':
          this.status = '已扫码，请在手机上确认登录';
          break;
        case 'success':
          this.status = '登录成功！';
          this.onLoginSuccess(event.data);
          this.isLoading = false;
          break;
        case 'expired':
          this.status = '二维码已过期';
          this.isLoading = false;
          break;
        case 'error':
          this.status = `错误: ${event.data.message}`;
          this.isLoading = false;
          break;
      }
    });
  }

  onLoginSuccess(data: any) {
    console.log('微博账号绑定成功:', data);
    // 刷新账号列表或导航到账号管理页面
  }
}
```

```typescript
// apps/admin/src/app/features/weibo/weibo-accounts.component.ts
import { Component, OnInit } from '@angular/core';
import { createWeiboAuthSDK, WeiboAccount } from '@pro/sdk';
import { AuthService } from '../../core/services/auth.service';

@Component({
  selector: 'app-weibo-accounts',
  template: `
    <div class="container mx-auto p-6">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-800">我的微博账号</h2>
        <button class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
          添加账号
        </button>
      </div>

      <!-- 账号列表 -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <div *ngFor="let account of accounts"
             class="bg-white rounded-lg shadow-md p-4 hover:shadow-lg transition-shadow">

          <!-- 账号头部 -->
          <div class="flex items-center space-x-4 mb-4">
            <img [src]="account.weiboAvatar"
                 [alt]="account.weiboNickname"
                 class="w-16 h-16 rounded-full object-cover">
            <div class="flex-1">
              <h3 class="font-semibold text-gray-800">{{ account.weiboNickname }}</h3>
              <p class="text-sm text-gray-500">UID: {{ account.weiboUid }}</p>
            </div>
          </div>

          <!-- 账号状态 -->
          <div class="mb-4">
            <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium"
                  [ngClass]="{
                    'bg-green-100 text-green-800': account.status === 'active',
                    'bg-red-100 text-red-800': account.status === 'expired',
                    'bg-gray-100 text-gray-800': account.status === 'banned'
                  }">
              {{ account.status === 'active' ? '正常' :
                 account.status === 'expired' ? '已过期' : '已封禁' }}
            </span>
          </div>

          <!-- 操作按钮 -->
          <div class="flex space-x-2">
            <button
              (click)="deleteAccount(account.id)"
              class="flex-1 px-3 py-2 bg-red-50 text-red-600 rounded-lg
                     hover:bg-red-100 transition-colors text-sm font-medium">
              删除
            </button>
            <button
              class="flex-1 px-3 py-2 bg-gray-50 text-gray-600 rounded-lg
                     hover:bg-gray-100 transition-colors text-sm font-medium">
              测试
            </button>
          </div>
        </div>
      </div>

      <!-- 空状态 -->
      <div *ngIf="accounts.length === 0"
           class="text-center py-12">
        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M12 4v16m8-8H4" />
        </svg>
        <h3 class="mt-2 text-sm font-medium text-gray-900">暂无微博账号</h3>
        <p class="mt-1 text-sm text-gray-500">开始添加您的第一个微博账号</p>
      </div>
    </div>
  `
})
export class WeiboAccountsComponent implements OnInit {
  accounts: WeiboAccount[] = [];

  private weiboSDK = createWeiboAuthSDK(this.getApiUrl());

  constructor(private authService: AuthService) {}

  private getApiUrl(): string {
    return 'http://localhost:3000';
  }

  async ngOnInit() {
    await this.loadAccounts();
  }

  async loadAccounts() {
    const token = this.authService.getToken();
    const result = await this.weiboSDK.getAccounts(token);
    this.accounts = result.accounts;
  }

  async deleteAccount(accountId: number) {
    if (!confirm('确定要删除此微博账号吗？')) {
      return;
    }

    const token = this.authService.getToken();
    await this.weiboSDK.deleteAccount(token, accountId);
    await this.loadAccounts(); // 重新加载列表
  }
}
```

### 8.5 SDK 接口封装 (@pro/sdk)
```typescript
// packages/sdk/src/weibo.interface.ts

// 微博账号信息
export interface WeiboAccount {
  id: number;
  weiboUid: string;
  weiboNickname: string;
  weiboAvatar: string;
  status: string;
  lastCheckAt?: string;
  createdAt: string;
}

// SSE 事件类型
export type WeiboLoginEventType = 'qrcode' | 'scanned' | 'status' | 'success' | 'expired' | 'error';

export interface WeiboLoginEvent {
  type: WeiboLoginEventType;
  data: any;
}

// 二维码事件数据
export interface QrcodeEventData {
  qrid: string;
  image: string;
}

// 成功事件数据
export interface SuccessEventData {
  accountId: number;
  weiboUid: string;
  weiboNickname: string;
  weiboAvatar: string;
}

// SSE 事件处理器
export type WeiboLoginEventHandler = (event: WeiboLoginEvent) => void;

// 微博登录 SDK
export interface WeiboAuthSDK {
  // 启动微博登录（SSE）
  startLogin(token: string, onEvent: WeiboLoginEventHandler): EventSource;

  // 获取账号列表
  getAccounts(token: string): Promise<{ accounts: WeiboAccount[] }>;

  // 删除账号
  deleteAccount(token: string, accountId: number): Promise<{ success: boolean }>;
}
```

```typescript
// packages/sdk/src/weibo-auth.sdk.ts

import { WeiboAuthSDK, WeiboLoginEventHandler } from './weibo.interface';

export class WeiboAuthSDKImpl implements WeiboAuthSDK {
  constructor(private baseUrl: string) {}

  startLogin(token: string, onEvent: WeiboLoginEventHandler): EventSource {
    const eventSource = new EventSource(
      `${this.baseUrl}/api/weibo/login/start`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );

    eventSource.addEventListener('message', (event) => {
      try {
        const message = JSON.parse(event.data);
        onEvent(message);

        // 自动关闭连接的事件类型
        if (['success', 'expired', 'error'].includes(message.type)) {
          eventSource.close();
        }
      } catch (error) {
        console.error('Failed to parse SSE message:', error);
      }
    });

    eventSource.onerror = () => {
      eventSource.close();
      onEvent({ type: 'error', data: { message: '连接失败' } });
    };

    return eventSource;
  }

  async getAccounts(token: string) {
    const response = await fetch(`${this.baseUrl}/api/weibo/accounts`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to fetch accounts');
    }

    return response.json();
  }

  async deleteAccount(token: string, accountId: number) {
    const response = await fetch(`${this.baseUrl}/api/weibo/accounts/${accountId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to delete account');
    }

    return response.json();
  }
}

// 导出实例创建函数
export function createWeiboAuthSDK(baseUrl: string): WeiboAuthSDK {
  return new WeiboAuthSDKImpl(baseUrl);
}
```

```typescript
// packages/sdk/src/index.ts
export * from './weibo.interface';
export * from './weibo-auth.sdk';
```

### 8.6 多账号并发处理
```typescript
// 使用 Map 管理多个登录会话
private loginSessions = new Map<string, BrowserContext>();

async startLogin(userId: number): Promise<Observable<MessageEvent>> {
  const sessionId = `${userId}_${Date.now()}`;
  const context = await this.browser.newContext();
  this.loginSessions.set(sessionId, context);

  // 超时自动清理
  setTimeout(() => {
    if (this.loginSessions.has(sessionId)) {
      context.close();
      this.loginSessions.delete(sessionId);
    }
  }, 300000); // 5分钟超时

  // ... 后续逻辑
}
```

## 九、待确认问题

1. ~~微博登录成功后如何处理？~~ ✅ **已确认**: 保存 Cookie 到数据库
2. ~~是否支持多账号？~~ ✅ **已确认**: 支持一个用户绑定多个微博账号
3. ~~二维码过期状态码？~~ ✅ **已确认**: `50114003` 表示过期
4. ~~扫码成功状态码？~~ ✅ **已确认**: `50114002` 已扫码等待确认
5. ~~登录成功如何判断？~~ ✅ **已确认**: 监控页面跳转到 `https://weibo.com/`
6. ~~Cookie 加密存储？~~ ✅ **已确认**: 不需要加密，直接存储
7. ~~用户信息获取？~~ ✅ **已确认**: 使用 `window.$CONFIG.user` 获取完整信息
   - `id`: 数字 ID
   - `idstr`: 字符串 ID
   - `screen_name`: 昵称
   - `avatar_hd`: 高清头像 URL
8. ~~前端接口调用？~~ ✅ **已确认**: 封装到 `@pro/sdk`，前端通过 SDK 调用
9. ~~前端样式框架？~~ ✅ **已确认**: 使用 Tailwind CSS
10. **二维码过期后是否自动刷新？** 建议：让用户手动重新获取
11. **Cookie 有效期检测机制？** 是否需要定期验证 Cookie 是否过期
12. **Playwright Docker 配置？** 需要在 Dockerfile 中安装浏览器依赖

## 十、注意事项

1. **Playwright 依赖**: Docker 镜像需要安装 Chromium 依赖
   ```dockerfile
   RUN apt-get update && apt-get install -y \
       chromium \
       chromium-driver
   ```

2. **SSE 连接**:
   - 需要正确处理超时和断线重连
   - 注意 CORS 和 Authorization 头支持

3. **资源清理**:
   - 浏览器上下文使用完必须关闭
   - 超时会话需要自动清理
   - 避免内存泄漏

4. **安全性**:
   - Cookie 明文存储（已确认不需要加密）
   - 账号只能被所属用户访问（权限验证）
   - 防止 SSRF 攻击

5. **反爬处理**:
   - 微博可能有反爬机制
   - 可能需要设置 User-Agent
   - 控制请求频率

6. **并发限制**:
   - 限制同一用户同时登录会话数
   - 限制浏览器实例总数

---

**文档状态**: ✅ 核心方案已确认，待实施
**创建时间**: 2025-10-08
**最后更新**: 2025-10-08

## 附录：提交策略

每个任务完成后都需要提交代码：

- **任务 A 完成后**: `git commit -m "feat(api): 添加微博账号数据库表"`
- **任务 B 完成后**: `git commit -m "feat(api): 配置 Playwright 环境"`
- **任务 C 完成后**: `git commit -m "feat(api): 实现微博登录服务"`
- **任务 D 完成后**: `git commit -m "feat(api): 实现 SSE 推送"`
- **任务 E 完成后**: `git commit -m "feat(api): 实现微博账号管理接口"`
- **任务 F 完成后**: `git commit -m "feat(sdk): 封装微博接口到 @pro/sdk"`
- **任务 G 完成后**: `git commit -m "feat(admin): 实现微博登录组件"`
- **任务 H 完成后**: `git commit -m "feat(admin): 实现微博账号管理页面"`
- **任务 I 完成后**: `git commit -m "test: 微博登录功能集成测试"`
