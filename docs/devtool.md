# 爬虫分析工具设计方案

## 一、项目概述

设计一个**API逆向工程工具**，能够监控目标网站的所有HTTP请求，捕获请求参数和响应数据，通过AI分析自动生成标准化的API接口文档，**让第三方网站的API从黑盒变成白盒**，方便后续开发使用。

### 核心价值
- **API发现**：自动发现目标网站的所有接口
- **参数解析**：智能解析请求参数和响应结构
- **文档生成**：自动生成OpenAPI/Swagger标准文档
- **代码示例**：生成多语言调用示例代码
- **关系梳理**：理清接口间的调用关系和数据依赖

## 二、核心功能

### 2.1 网络监控模块
- 输入目标URL启动监控
- 拦截并记录所有HTTP/HTTPS请求
- 捕获请求头、请求参数（Query/Body）
- 捕获响应头、响应数据
- 记录请求时序和调用链

### 2.2 数据存储模块
- 存储请求元数据（URL、Method、Headers）
- 存储请求参数（原始格式+结构化）
- 存储响应数据（原始格式+结构化）
- 记录请求时间戳和调用上下文
- 建立请求间的关联关系

### 2.3 AI分析模块
- 分析接口功能（CRUD操作类型）
- 识别接口用途（登录/列表/详情/搜索等）
- 分析数据结构和字段含义
- 发现数据关联关系（主外键/嵌套引用）
- 识别分页模式（页码/偏移量/游标）
- 分析数据流向和页面渲染逻辑

### 2.4 文档生成模块（核心产出）
- 生成OpenAPI 3.0规范文档
- 生成接口描述和参数说明
- 生成请求/响应示例
- 生成数据模型（Schema）
- 生成认证方式说明
- 生成多语言调用代码示例（curl/JavaScript/Python/Java）
- 支持导出Markdown/HTML/PDF格式
- 支持导入Postman/Apifox等工具

### 2.5 可视化展示模块
- 请求列表展示（时间轴视图）
- 接口调用链路图
- 数据关系拓扑图
- 接口分类和标签
- AI分析结果展示
- 在线API文档预览（Swagger UI）

## 三、技术架构

### 3.1 浏览器监控方案（已确定）
**采用方案：Playwright + 用户手动操作**
- 后端启动Playwright浏览器实例（headful模式）
- 用户直接操作Playwright浏览器界面
- 后台通过Chrome DevTools Protocol监控所有网络请求
- 监控持续到用户主动关闭浏览器
- Playwright自动保持登录态（Session/Cookie）

**技术优势**：
- ✅ 无需编写自动化脚本
- ✅ 用户可灵活操作（点击、滚动、表单填写）
- ✅ 自动处理登录态和Cookie
- ✅ 支持复杂交互场景（验证码、人机验证）
- ✅ 实时捕获所有XHR/Fetch/WebSocket请求

### 3.2 数据存储方案
- **PostgreSQL**：存储结构化的请求/响应元数据
- **MongoDB/JSON**：存储原始请求/响应体
- **Redis**：缓存会话数据和临时分析结果

### 3.3 AI分析方案
- **大模型选择**：Claude/GPT-4 API
- **分析策略**：
  - 单请求分析：解读单个API的作用
  - 批量分析：发现请求间的关联模式
  - 增量学习：基于历史分析结果优化

### 3.4 技术栈
- **后端**：NestJS（已有技术栈）
- **监控层**：Playwright + Chrome DevTools Protocol
- **数据层**：PostgreSQL + TypeORM
- **AI层**：Claude API / OpenAI API
- **前端**：Angular（已有技术栈）
- **实时通信**：WebSocket / Server-Sent Events

### 3.5 系统架构图
```
┌─────────────────────────────────────────────────────────────┐
│                         前端（Angular）                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ 任务管理界面 │  │ 请求列表展示 │  │ 文档预览导出 │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└───────────────────────────┬─────────────────────────────────┘
                            │ WebSocket/SSE（实时推送请求）
┌───────────────────────────┴─────────────────────────────────┐
│                      后端（NestJS）                          │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              监控模块                                 │  │
│  │  • 启动/管理Playwright浏览器实例                     │  │
│  │  • 监听CDP事件（Network.requestWillBeSent等）       │  │
│  │  • 解析请求/响应数据                                 │  │
│  │  • 实时存储到数据库                                  │  │
│  └──────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              AI分析模块                               │  │
│  │  • URL模式归并（/user/123 → /user/{id}）            │  │
│  │  • 生成JSON Schema                                   │  │
│  │  • 调用Claude API分析接口用途                        │  │
│  │  • 识别数据关系和分页模式                            │  │
│  └──────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              文档生成模块                             │  │
│  │  • 组装OpenAPI 3.0规范                               │  │
│  │  • 生成多语言代码示例                                │  │
│  │  • 导出Markdown/JSON/YAML                           │  │
│  └──────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────┴─────────────────────────────────┐
│                  数据层（PostgreSQL）                        │
│  • monitoring_task（监控任务）                              │
│  • http_request/response（请求/响应）                       │
│  • api_analysis（AI分析结果）                               │
│  • api_documentation（API文档）                             │
│  • data_relationship（数据关系）                            │
└─────────────────────────────────────────────────────────────┘

         ┌───────────────────────────────────┐
         │  Playwright浏览器（用户操作）     │
         │  • 用户手动登录、翻页、点击       │
         │  • 后台CDP监控所有网络请求         │
         └───────────────────────────────────┘
```

## 四、数据模型设计

### 4.1 监控任务表（monitoring_task）
```
- id: 任务ID
- target_url: 目标URL
- status: 监控状态（运行中/已停止/已完成）
- start_time: 开始时间
- end_time: 结束时间
- config: 监控配置（JSON）
```

### 4.2 请求记录表（http_request）
```
- id: 请求ID
- task_id: 所属任务
- url: 请求URL
- method: HTTP方法
- headers: 请求头（JSON）
- query_params: Query参数（JSON）
- body_params: Body参数（JSON）
- timestamp: 请求时间
- parent_request_id: 父请求ID（建立调用链）
```

### 4.3 响应记录表（http_response）
```
- id: 响应ID
- request_id: 对应请求ID
- status_code: HTTP状态码
- headers: 响应头（JSON）
- body: 响应体（JSON/TEXT）
- size: 响应大小
- duration: 响应时长
```

### 4.4 AI分析结果表（api_analysis）
```
- id: 分析ID
- request_id: 对应请求ID
- api_purpose: 接口用途（登录/列表/详情等）
- operation_type: 操作类型（CRUD）
- data_schema: 数据结构（JSON Schema）
- pagination_info: 分页信息（JSON）
- relationships: 关联关系（JSON）
- ai_insights: AI分析洞察（TEXT）
- confidence: 置信度
```

### 4.5 数据关系表（data_relationship）
```
- id: 关系ID
- source_request_id: 源请求ID
- target_request_id: 目标请求ID
- relationship_type: 关系类型（主从/分页/详情跳转）
- field_mapping: 字段映射（JSON）
- description: 关系描述
```

### 4.6 API文档表（api_documentation）
```
- id: 文档ID
- task_id: 所属任务
- api_path: 接口路径（去参数化，如/api/user/{id}）
- api_name: 接口名称（AI生成）
- api_description: 接口描述（AI生成）
- http_method: HTTP方法
- category: 接口分类（用户/商品/订单等）
- auth_required: 是否需要认证
- auth_type: 认证类型（Cookie/Token/None）
- request_headers: 请求头定义（JSON Schema）
- request_params: 请求参数定义（JSON Schema）
- response_schema: 响应数据定义（JSON Schema）
- request_examples: 请求示例（JSON数组）
- response_examples: 响应示例（JSON数组）
- error_codes: 错误码说明（JSON）
- code_samples: 代码示例（JSON，多语言）
- openapi_spec: OpenAPI规范（JSON）
- created_at: 创建时间
- updated_at: 更新时间
```

### 4.7 API分组表（api_group）
```
- id: 分组ID
- task_id: 所属任务
- group_name: 分组名称（如"用户管理"）
- description: 分组描述
- base_url: 基础URL
- order: 排序
```

## 五、核心流程

### 5.1 监控流程（用户交互模式）
```
1. 用户在前端创建监控任务，输入目标URL
2. 后端创建任务记录，生成任务ID
3. 后端启动Playwright浏览器实例（headful模式）
4. 启用Chrome DevTools Protocol监控
5. 自动打开目标URL（可选预填）
6. 用户手动操作浏览器（登录、翻页、点击详情等）
7. 后台实时拦截所有网络请求（XHR/Fetch/WebSocket）
8. 解析请求参数和响应数据
9. 实时存储到数据库
10. 前端实时展示捕获的请求列表
11. 用户操作完成后，关闭浏览器窗口
12. 后端检测到浏览器关闭，标记任务完成
13. 触发AI分析和文档生成
```

### 5.2 分析流程
```
1. 从数据库批量读取请求数据
2. 按URL分组归类
3. 对每组请求构建分析prompt
4. 调用AI API进行分析
5. 解析AI返回的结构化结果
6. 存储分析结果到数据库
7. 建立数据关系图谱
```

### 5.3 关系发现流程
```
1. 识别列表接口（返回数组数据）
2. 识别详情接口（通过ID参数关联）
3. 分析分页参数（page/pageSize/offset/cursor）
4. 发现字段引用（ID字段在不同接口间传递）
5. 构建数据依赖图
```

### 5.4 文档生成流程（核心）
```
1. URL模式归并（/api/user/123 → /api/user/{id}）
2. 提取公共请求头（如Authorization）
3. 生成请求参数JSON Schema
4. 生成响应数据JSON Schema
5. AI生成接口名称和描述
6. AI识别接口分类和标签
7. 生成请求/响应示例
8. 生成错误码说明
9. 生成代码示例（curl/JS/Python）
10. 组装OpenAPI 3.0规范文档
11. 存储到api_documentation表
12. 支持导出多种格式
```

### 5.5 代码示例生成流程
```
1. 基于请求参数生成curl命令
2. 生成JavaScript (fetch/axios) 示例
3. 生成Python (requests) 示例
4. 生成Java (OkHttp/RestTemplate) 示例
5. 自动处理认证Header
6. 使用真实的请求示例数据
```

## 六、任务拆分

### 阶段一：基础设施（优先级：高）
- [ ] T1.1 创建数据库表结构和Entity
- [ ] T1.2 实现监控任务CRUD接口
- [ ] T1.3 搭建Puppeteer监控服务

**依赖关系**：T1.2依赖T1.1，T1.3独立

### 阶段二：网络监控（优先级：高）
- [ ] T2.1 实现Chrome DevTools Protocol集成
- [ ] T2.2 实现请求拦截和数据捕获
- [ ] T2.3 实现请求/响应数据存储
- [ ] T2.4 实现调用链关系建立

**依赖关系**：T2.1 → T2.2 → T2.3, T2.4依赖T2.3

### 阶段三：AI分析引擎（优先级：中）
- [ ] T3.1 设计AI分析Prompt模板
- [ ] T3.2 实现单请求分析功能
- [ ] T3.3 实现批量请求归类分析
- [ ] T3.4 实现数据关系发现算法
- [ ] T3.5 实现分页模式识别

**依赖关系**：T3.1 → T3.2, T3.3, T3.4, T3.5（后四者可并行）

### 阶段四：数据关系图谱（优先级：中）
- [ ] T4.1 实现请求调用链分析
- [ ] T4.2 实现数据依赖关系构建
- [ ] T4.3 实现关系图谱存储

**依赖关系**：T4.1和T4.2可并行，T4.3依赖前两者

### 阶段五：文档生成引擎（优先级：高）
- [ ] T5.1 实现URL模式归并算法
- [ ] T5.2 实现JSON Schema自动生成
- [ ] T5.3 实现OpenAPI 3.0规范组装
- [ ] T5.4 实现多语言代码示例生成
- [ ] T5.5 实现文档导出功能（Markdown/JSON/YAML）
- [ ] T5.6 集成Swagger UI在线预览

**依赖关系**：T5.1 → T5.2 → T5.3，T5.4和T5.5依赖T5.3，T5.6依赖T5.3

### 阶段六：前端展示（优先级：中）
- [ ] T6.1 监控任务管理界面
- [ ] T6.2 请求列表和详情展示
- [ ] T6.3 调用链可视化组件
- [ ] T6.4 数据关系图可视化
- [ ] T6.5 API文档在线预览和导出
- [ ] T6.6 代码示例展示和复制

**依赖关系**：T6.1独立，其他依赖对应后端接口

## 七、技术难点与解决方案

### 7.1 浏览器实例管理
**问题**：如何管理多个监控任务的浏览器实例
**方案**：
- 每个任务对应一个独立的Playwright浏览器实例
- 使用进程ID关联任务和浏览器
- 浏览器关闭时通过事件监听自动清理资源
- 支持任务超时强制关闭（可选）

### 7.2 实时数据同步
**问题**：前端如何实时展示后台捕获的请求
**方案**：
- WebSocket推送新请求到前端
- 或使用Server-Sent Events (SSE)
- 前端增量渲染请求列表

### 7.3 加密或混淆的接口参数
**问题**：参数加密导致AI无法理解
**方案**：记录原始加密参数，尝试从JS代码中提取加密逻辑

### 7.4 大量请求的AI分析成本
**问题**：每个请求都调用AI成本高
**方案**：
- 按URL模式去重（/api/user/123 和 /api/user/456 视为同一接口）
- 批量分析相似请求
- 缓存分析结果

### 7.4 复杂的数据关系识别
**问题**：数据间关系隐蔽且复杂
**方案**：
- 通过字段名相似度匹配（如userId和id）
- 通过数据值匹配（一个接口返回的ID在另一个接口请求中出现）
- 时序分析（先请求列表再请求详情）

### 7.5 WebSocket和SSE监控
**问题**：实时通信协议的监控
**方案**：扩展监控能力支持WebSocket和Server-Sent Events

### 7.6 URL参数化识别
**问题**：如何识别/api/user/123和/api/user/456是同一个接口
**方案**：
- 使用正则匹配数字/UUID模式
- 通过响应结构相似度判断
- AI识别路径参数语义（如{id}/{userId}）

### 7.7 动态字段处理
**问题**：不同请求返回字段不一致
**方案**：
- 合并多个样本生成完整Schema
- 标记可选字段（optional）
- 记录字段出现频率

### 7.8 认证方式识别
**问题**：如何识别接口的认证方式
**方案**：
- 检测Authorization Header
- 检测Cookie中的token
- 分析401/403响应
- AI识别登录接口流程

## 八、迭代计划

### MVP版本（最小可行产品）
- 基础监控功能（HTTP请求记录）
- URL模式归并和去重
- 简单的AI分析（接口用途识别）
- **生成基础OpenAPI文档（核心）**
- **导出JSON/YAML格式（核心）**

### V1.0版本（完整文档生成）
- 完整的网络监控
- AI深度分析（参数语义、数据关系）
- **生成完整OpenAPI 3.0规范**
- **生成多语言代码示例**
- **Swagger UI在线预览**
- **导出Markdown格式文档**
- 接口分类和标签
- 认证方式识别

### V2.0版本（高级功能）
- 支持浏览器扩展模式
- 支持WebSocket监控
- **导出Postman/Apifox格式**
- **生成API Mock Server配置**
- **生成SDK代码（TypeScript/Python）**
- 可视化调用链和关系图
- 智能爬虫建议（自动生成爬虫代码）

## 九、最终产出（重点）

### 9.1 核心产出：API接口文档
**格式1：OpenAPI 3.0规范文档**
- 标准JSON/YAML格式
- 可导入Swagger/Postman/Apifox
- 包含完整的请求/响应定义
- 包含认证配置
- 包含服务器地址

**格式2：Markdown文档**
- 适合人类阅读
- 包含目录和分类
- 每个接口独立章节
- 包含代码示例
- 可导出为HTML/PDF

**格式3：在线文档**
- Swagger UI在线预览
- 支持在线测试接口
- 支持分享链接

### 9.2 辅助产出
1. **代码示例库**：curl/JavaScript/Python/Java调用示例
2. **数据字典**：字段含义和类型说明
3. **接口调用关系图**：可视化接口依赖
4. **认证指南**：如何获取和使用Token/Cookie
5. **错误码文档**：常见错误及解决方案

### 9.3 文档质量标准
- ✅ 每个接口有清晰的名称和描述
- ✅ 每个参数有类型、是否必填、含义说明
- ✅ 每个响应有完整的数据结构定义
- ✅ 提供真实的请求/响应示例
- ✅ 标注接口间的关联关系
- ✅ 提供可运行的代码示例

## 十、开放问题（待确认）

### 监控范围（已确定✅）
1. ✅ **登录态管理**：Playwright自动保持，无需额外操作
2. ✅ **用户操作**：用户直接操作Playwright浏览器界面，后台监控
3. ✅ **监控时长**：持续到用户主动关闭浏览器窗口
4. ❓ 是否需要支持多任务并行监控（同时监控多个网站）？

### AI分析深度
5. AI分析需要多深入？
   - 基础：识别接口类型（CRUD）、参数类型
   - 中级：理解字段含义、数据关系
   - 高级：理解业务逻辑、生成业务文档

### 文档格式
6. 优先支持哪些导出格式？
   - 必须：OpenAPI JSON/YAML
   - 重要：Markdown、Swagger UI
   - 可选：Postman Collection、Apifox、HTML/PDF

### 代码示例
7. 需要支持哪些编程语言的代码示例？
   - 建议：curl、JavaScript、Python
   - 可选：Java、Go、PHP、Ruby

### 特殊场景
8. 是否需要处理加密接口（参数加密/签名）？
9. 是否需要支持GraphQL接口？
10. 是否需要生成Mock Server配置或SDK代码？

---

## 十一、使用流程详解

### 完整使用流程
```
第1步：创建监控任务
  • 用户在前端界面点击"新建监控任务"
  • 输入目标网站URL（如：https://weibo.com）
  • （可选）填写任务名称和备注
  • 点击"启动监控"

第2步：浏览器自动启动
  • 后端接收请求，创建monitoring_task记录
  • 启动Playwright浏览器实例（headful模式）
  • 浏览器窗口弹出，自动打开目标URL
  • 后台启用CDP网络监控

第3步：用户手动操作
  • 用户在Playwright浏览器中操作：
    - 登录账号（自动保持登录态）
    - 浏览列表页（滚动加载更多）
    - 点击详情页
    - 搜索、筛选、分页等任意操作
  • 后台实时捕获所有网络请求
  • 前端界面实时显示捕获的请求列表（通过WebSocket推送）

第4步：用户关闭浏览器
  • 用户完成操作后，关闭Playwright浏览器窗口
  • 后端检测到浏览器关闭事件
  • 自动标记任务状态为"已完成"
  • 触发AI分析流程

第5步：AI自动分析
  • URL模式归并（去重相似接口）
  • 生成JSON Schema
  • 调用Claude API分析接口用途和字段含义
  • 识别数据关系（列表→详情、分页逻辑等）
  • 生成接口分类和标签

第6步：生成API文档
  • 组装OpenAPI 3.0规范文档
  • 生成多语言代码示例（curl/JS/Python）
  • 存储到api_documentation表
  • 前端展示"文档已生成"通知

第7步：查看和导出
  • 用户查看生成的API文档
  • 在线预览（Swagger UI）
  • 导出多种格式：
    - OpenAPI JSON/YAML（导入Postman/Apifox）
    - Markdown文档（人类阅读）
    - 复制代码示例
```

### 前端界面交互
```
┌────────────────────────────────────────────────────────┐
│  任务列表                                    [新建任务] │
├────────────────────────────────────────────────────────┤
│  任务名称        目标URL          状态      操作        │
│  微博API分析    weibo.com        运行中    [停止]      │
│  淘宝商品接口    taobao.com       已完成    [查看文档]  │
└────────────────────────────────────────────────────────┘

[点击"新建任务"]
┌────────────────────────────────────────────────────────┐
│  创建监控任务                                          │
├────────────────────────────────────────────────────────┤
│  任务名称：[微博搜索接口分析___________________]       │
│  目标URL： [https://weibo.com__________________]       │
│  备注：    [分析微博搜索和详情接口_____________]       │
│                                                        │
│                          [取消]  [启动监控]           │
└────────────────────────────────────────────────────────┘

[启动后实时展示]
┌────────────────────────────────────────────────────────┐
│  任务：微博搜索接口分析              [停止监控] [生成文档]│
├────────────────────────────────────────────────────────┤
│  捕获的请求 (23个)                        [筛选: 全部▼] │
│  ┌────────────────────────────────────────────────────┐│
│  │ GET /api/search?q=keyword&page=1        200  234ms ││
│  │ GET /api/user/profile?uid=123456        200  156ms ││
│  │ GET /api/weibo/detail?id=789            200  198ms ││
│  │ POST /api/comment/list                  200  267ms ││
│  └────────────────────────────────────────────────────┘│
│                                                        │
│  [点击任意请求查看详情]                                 │
└────────────────────────────────────────────────────────┘
```

## 十二、使用场景举例

### 场景1：逆向分析竞品API（微博搜索）
```
1. 创建任务，输入 https://weibo.com
2. Playwright浏览器打开微博首页
3. 用户手动登录账号
4. 在搜索框输入关键词"AI"并搜索
5. 浏览搜索结果，翻页到第3页
6. 点击某条微博查看详情
7. 查看评论列表
8. 关闭浏览器
9. 系统自动分析，生成：
   - /api/search 搜索接口文档
   - /api/weibo/detail 详情接口文档
   - /api/comment/list 评论接口文档
   - 分页参数分析（page/count）
   - 数据关系（搜索→详情→评论）
10. 导出OpenAPI文档，供开发微博爬虫使用
```

### 场景2：爬虫开发前期调研（电商网站）
```
1. 监控目标电商网站
2. 用户手动操作：搜索商品、筛选价格、查看详情、评论
3. 后台捕获所有API请求
4. AI分析生成：
   - 商品搜索接口（带筛选参数）
   - 商品详情接口
   - 评论列表接口（含分页）
   - 价格变动接口
5. 生成Python requests代码示例
6. 快速开发爬虫脚本
```

### 场景3：前后端协作（内部系统）
```
1. 前端开发者监控自己开发的系统
2. 操作所有功能模块
3. 自动生成完整API文档
4. 导出Markdown文档
5. 分享给后端团队Review
6. 发现文档缺失或接口设计问题
7. 优化接口设计或补充注释
```
