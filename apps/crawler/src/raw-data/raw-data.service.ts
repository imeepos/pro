import { Injectable, Inject } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Logger } from '@pro/logger';
import { Model } from 'mongoose';
import { createHash } from 'crypto';
import * as cheerio from 'cheerio';
import { RabbitMQClient } from '@pro/rabbitmq';
import { QUEUE_NAMES, RawDataReadyEvent, SourcePlatform } from '@pro/types';

export interface RawDataSource {
  _id?: any;
  sourceType: string;
  sourceUrl: string;
  rawContent: string;
  contentHash: string;
  metadata: Record<string, any>;
  status: 'pending' | 'processed' | 'failed';
  sourcePlatform?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface RabbitMQConfig {
  url: string;
}

@Injectable()
export class RawDataService {
  private rabbitMQClient: RabbitMQClient | null = null;
  private isRabbitMQConnected = false;
  private publishRetryCount = 0;
  private readonly MAX_PUBLISH_RETRIES = 3;

  constructor(
    @InjectModel('RawDataSource') private rawDataSourceModel: Model<RawDataSource>,
    private readonly logger: Logger,
    @Inject('RABBITMQ_CONFIG') private readonly rabbitmqConfig: RabbitMQConfig
  ) {
    this.initializeRabbitMQ();
  }

  async create(data: {
    sourceType: string;
    sourceUrl: string;
    rawContent: string;
    metadata: Record<string, any>;
  }): Promise<RawDataSource> {
    const createStartTime = Date.now();
    const contentSize = data.rawContent.length;
    const contentHash = this.generateContentHash(data.rawContent);

    this.logger.debug('üíæ ÂºÄÂßãÂ≠òÂÇ®ÂéüÂßãÊï∞ÊçÆ', {
      sourceType: data.sourceType,
      sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
      contentSize,
      contentSizeKB: Math.round(contentSize / 1024),
      contentHash: contentHash.substring(0, 16) + '...',
      traceId: data.metadata.traceId,
      taskId: data.metadata.taskId
    }, 'RawDataService');

    // Ê£ÄÊü•Âü∫‰∫é contentHash ÁöÑÈáçÂ§ç
    const hashCheckStart = Date.now();
    const existingByHash = await this.rawDataSourceModel.findOne({
      sourceType: data.sourceType,
      contentHash: contentHash
    });
    const hashCheckDuration = Date.now() - hashCheckStart;

    if (existingByHash) {
      this.logger.log('‚ôªÔ∏è ÂèëÁé∞ÈáçÂ§çÂÜÖÂÆπÔºåË∑≥ËøáÂ≠òÂÇ®', {
        sourceType: data.sourceType,
        sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
        contentHash: contentHash.substring(0, 16) + '...',
        existingId: existingByHash._id,
        existingCreatedAt: existingByHash.createdAt?.toISOString(),
        hashCheckDuration,
        totalDuration: Date.now() - createStartTime,
        traceId: data.metadata.traceId
      }, 'RawDataService');
      return existingByHash;
    }

    // Ê£ÄÊü•Âü∫‰∫é sourceUrl ÁöÑÈáçÂ§ç
    const urlCheckStart = Date.now();
    const existingByUrl = await this.rawDataSourceModel.findOne({
      sourceUrl: data.sourceUrl
    });
    const urlCheckDuration = Date.now() - urlCheckStart;

    if (existingByUrl) {
      this.logger.log('üîó ÂèëÁé∞ÈáçÂ§çURLÔºåË∑≥ËøáÂ≠òÂÇ®', {
        sourceType: data.sourceType,
        sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
        existingId: existingByUrl._id,
        existingCreatedAt: existingByUrl.createdAt?.toISOString(),
        urlCheckDuration,
        totalDuration: Date.now() - createStartTime,
        contentHashDifferent: existingByUrl.contentHash !== contentHash,
        traceId: data.metadata.traceId
      }, 'RawDataService');
      return existingByUrl;
    }

    const createdRecord = new this.rawDataSourceModel({
      sourceType: data.sourceType,
      sourceUrl: data.sourceUrl,
      rawContent: data.rawContent,
      contentHash: contentHash,
      metadata: data.metadata,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date()
    });

    this.logger.debug('üìù ÂáÜÂ§á‰øùÂ≠òÊñ∞ËÆ∞ÂΩï', {
      sourceType: data.sourceType,
      recordSize: Math.round(JSON.stringify(createdRecord.toObject()).length / 1024) + 'KB',
      metadataKeys: Object.keys(data.metadata),
      traceId: data.metadata.traceId
    }, 'RawDataService');

    try {
      const saveStart = Date.now();
      const savedRecord = await createdRecord.save();
      const saveDuration = Date.now() - saveStart;
      const totalDuration = Date.now() - createStartTime;

      this.logger.log('‚úÖ ÂéüÂßãÊï∞ÊçÆÂ≠òÂÇ®ÊàêÂäü', {
        sourceType: data.sourceType,
        recordId: savedRecord._id,
        sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
        contentSize,
        contentSizeKB: Math.round(contentSize / 1024),
        hashCheckDuration,
        urlCheckDuration,
        saveDuration,
        totalDuration,
        throughput: Math.round((contentSize / 1024) / (totalDuration / 1000) * 100) / 100, // KB/s
        traceId: data.metadata.traceId,
        taskId: data.metadata.taskId
      }, 'RawDataService');

      await this.publishRawDataReady(savedRecord);

      return savedRecord;

    } catch (error: any) {
      const totalDuration = Date.now() - createStartTime;

      // Â§ÑÁêÜ MongoDB E11000 ÈáçÂ§çÈîÆÈîôËØØ
      if (error.code === 11000) {
        this.logger.warn('‚ö†Ô∏è Ê£ÄÊµãÂà∞MongoDBÈáçÂ§çÈîÆÂÜ≤Á™Å', {
          sourceType: data.sourceType,
          sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
          errorMessage: error.message,
          errorCode: error.code,
          totalDuration,
          traceId: data.metadata.traceId
        }, 'RawDataService');

        // Ê†πÊçÆÈîôËØØ‰ø°ÊÅØÂà§Êñ≠ÊòØ sourceUrl ËøòÊòØ contentHash ÂÜ≤Á™Å
        if (error.message.includes('sourceUrl_1')) {
          const existing = await this.rawDataSourceModel.findOne({ sourceUrl: data.sourceUrl });
          if (existing) {
            this.logger.log('üîÑ Â∑≤Ëé∑ÂèñÈáçÂ§çURLÁöÑÁé∞ÊúâËÆ∞ÂΩï', {
              sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
              existingId: existing._id,
              existingCreatedAt: existing.createdAt?.toISOString(),
              conflictType: 'sourceUrl',
              totalDuration,
              traceId: data.metadata.traceId
            }, 'RawDataService');
            return existing;
          }
        }

        if (error.message.includes('contentHash')) {
          const existing = await this.rawDataSourceModel.findOne({ contentHash: contentHash });
          if (existing) {
            this.logger.log('üîÑ Â∑≤Ëé∑ÂèñÈáçÂ§çÂÜÖÂÆπÁöÑÁé∞ÊúâËÆ∞ÂΩï', {
              contentHash: contentHash.substring(0, 16) + '...',
              existingId: existing._id,
              existingCreatedAt: existing.createdAt?.toISOString(),
              conflictType: 'contentHash',
              totalDuration,
              traceId: data.metadata.traceId
            }, 'RawDataService');
            return existing;
          }
        }
      }

      // ËÆ∞ÂΩïÂÖ∂‰ªñÁ±ªÂûãÁöÑÈîôËØØ
      this.logger.error('‚ùå ÂéüÂßãÊï∞ÊçÆÂ≠òÂÇ®Â§±Ë¥•', {
        sourceType: data.sourceType,
        sourceUrl: data.sourceUrl.length > 100 ? data.sourceUrl.substring(0, 100) + '...' : data.sourceUrl,
        contentSize,
        contentHash: contentHash.substring(0, 16) + '...',
        error: error.message,
        errorCode: error.code,
        errorType: this.classifyStorageError(error),
        totalDuration,
        traceId: data.metadata.traceId,
        stack: error.stack
      }, 'RawDataService');

      // ÈáçÊñ∞ÊäõÂá∫ÈùûÈáçÂ§çÈîÆÁöÑÂÖ∂‰ªñÈîôËØØ
      throw error;
    }
  }

  async findBySourceUrl(sourceUrl: string): Promise<RawDataSource | null> {
    return this.rawDataSourceModel.findOne({ sourceUrl }).exec();
  }

  async findByMetadata(metadataQuery: Record<string, any>): Promise<RawDataSource[]> {
    const query: any = {};
    for (const [key, value] of Object.entries(metadataQuery)) {
      query[`metadata.${key}`] = value;
    }
    return this.rawDataSourceModel.find(query).sort({ createdAt: -1 }).exec();
  }

  async findByTaskId(taskId: number): Promise<RawDataSource[]> {
    return this.rawDataSourceModel
      .find({ 'metadata.taskId': taskId })
      .sort({ createdAt: -1 })
      .exec();
  }

  async findByKeywordAndTimeRange(
    keyword: string,
    startTime: Date,
    endTime: Date
  ): Promise<RawDataSource[]> {
    return this.rawDataSourceModel
      .find({
        'metadata.keyword': keyword,
        createdAt: {
          $gte: startTime,
          $lte: endTime
        }
      })
      .sort({ createdAt: -1 })
      .exec();
  }

  async updateStatus(id: string, status: 'pending' | 'processed' | 'failed'): Promise<void> {
    await this.rawDataSourceModel.updateOne(
      { _id: id },
      { status, updatedAt: new Date() }
    );
  }

  async getStatistics(sourceType?: string): Promise<{
    total: number;
    pending: number;
    processed: number;
    failed: number;
    byDate: Array<{ date: string; count: number }>;
  }> {
    const statsStartTime = Date.now();

    this.logger.debug('üìä ÂºÄÂßãËé∑ÂèñÂ≠òÂÇ®ÁªüËÆ°‰ø°ÊÅØ', {
      sourceType,
      timestamp: new Date().toISOString()
    }, 'RawDataService');

    const matchQuery = sourceType ? { sourceType } : {};

    try {
      const aggStart = Date.now();
      const stats = await this.rawDataSourceModel.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            pending: { $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] } },
            processed: { $sum: { $cond: [{ $eq: ['$status', 'processed'] }, 1, 0] } },
            failed: { $sum: { $cond: [{ $eq: ['$status', 'failed'] }, 1, 0] } }
          }
        }
      ]);
      const aggDuration = Date.now() - aggStart;

      const dateAggStart = Date.now();
      const byDateStats = await this.rawDataSourceModel.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: {
              $dateToString: {
                format: '%Y-%m-%d',
                date: '$createdAt'
              }
            },
            count: { $sum: 1 }
          }
        },
        { $sort: { _id: -1 } },
        { $limit: 30 }
      ]);
      const dateAggDuration = Date.now() - dateAggStart;

      const totalDuration = Date.now() - statsStartTime;

      const result = {
        total: stats[0]?.total || 0,
        pending: stats[0]?.pending || 0,
        processed: stats[0]?.processed || 0,
        failed: stats[0]?.failed || 0,
        byDate: byDateStats.map(item => ({
          date: item._id,
          count: item.count
        }))
      };

      this.logger.debug('‚úÖ Â≠òÂÇ®ÁªüËÆ°‰ø°ÊÅØËé∑ÂèñÂÆåÊàê', {
        sourceType,
        stats: result,
        aggDuration,
        dateAggDuration,
        totalDuration,
        performance: {
          aggregationSpeed: Math.round((byDateStats.length + 1) / (totalDuration / 1000) * 100) / 100, // Êü•ËØ¢/Áßí
          avgAggTime: Math.round(totalDuration / 2) // Âπ≥ÂùáËÅöÂêàÊó∂Èó¥
        }
      }, 'RawDataService');

      return result;

    } catch (error) {
      const totalDuration = Date.now() - statsStartTime;
      this.logger.error('‚ùå Ëé∑ÂèñÂ≠òÂÇ®ÁªüËÆ°‰ø°ÊÅØÂ§±Ë¥•', {
        sourceType,
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        errorType: this.classifyStorageError(error),
        totalDuration,
        traceId: 'stats_query'
      }, 'RawDataService');
      throw error;
    }
  }

  async cleanupOldData(daysToKeep: number = 90): Promise<number> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

    const result = await this.rawDataSourceModel.deleteMany({
      createdAt: { $lt: cutoffDate },
      status: 'processed'
    });

    return result.deletedCount || 0;
  }

  private generateContentHash(content: string): string {
    return createHash('md5')
      .update(content)
      .digest('hex');
  }

  async searchContent(query: {
    keyword?: string;
    sourceType?: string;
    status?: string;
    startTime?: Date;
    endTime?: Date;
    page?: number;
    limit?: number;
  }): Promise<{
    data: RawDataSource[];
    total: number;
    page: number;
    limit: number;
  }> {
    const {
      keyword,
      sourceType,
      status,
      startTime,
      endTime,
      page = 1,
      limit = 20
    } = query;

    const filter: any = {};

    if (sourceType) {
      filter.sourceType = sourceType;
    }

    if (status) {
      filter.status = status;
    }

    if (startTime || endTime) {
      filter.createdAt = {};
      if (startTime) filter.createdAt.$gte = startTime;
      if (endTime) filter.createdAt.$lte = endTime;
    }

    if (keyword) {
      filter.$or = [
        { 'metadata.keyword': { $regex: keyword, $options: 'i' } },
        { rawContent: { $regex: keyword, $options: 'i' } }
      ];
    }

    const skip = (page - 1) * limit;
    const [data, total] = await Promise.all([
      this.rawDataSourceModel
        .find(filter)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.rawDataSourceModel.countDocuments(filter)
    ]);

    return {
      data,
      total,
      page,
      limit
    };
  }

  /**
   * ÂàÜÁ±ªÂ≠òÂÇ®ÈîôËØØ
   */
  private classifyStorageError(error: any): string {
    if (!error) return 'UNKNOWN_STORAGE_ERROR';

    if (error.code === 11000) {
      return 'DUPLICATE_KEY_ERROR';
    }

    const errorMessage = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();

    if (errorMessage.includes('connection') || errorMessage.includes('econnrefused')) {
      return 'MONGODB_CONNECTION_ERROR';
    }

    if (errorMessage.includes('timeout') || errorMessage.includes('etimedout')) {
      return 'MONGODB_TIMEOUT_ERROR';
    }

    if (errorMessage.includes('validation') || errorMessage.includes('cast')) {
      return 'DATA_VALIDATION_ERROR';
    }

    if (errorMessage.includes('disk') || errorMessage.includes('space')) {
      return 'DISK_SPACE_ERROR';
    }

    if (errorMessage.includes('index') || errorMessage.includes('duplicate')) {
      return 'INDEX_ERROR';
    }

    return 'UNKNOWN_STORAGE_ERROR';
  }

  /**
   * Ëé∑ÂèñÂ≠òÂÇ®ÊÄßËÉΩÊä•Âëä
   */
  async getStoragePerformanceReport(): Promise<{
    summary: {
      totalRecords: number;
      totalSizeMB: number;
      averageRecordSizeKB: number;
      indexEfficiency: number;
      queryPerformance: {
        avgQueryTime: number;
        slowQueries: number;
        fastQueries: number;
      };
    };
    operations: {
      insertPerformance: {
        avgInsertTime: number;
        insertThroughput: number; // records/second
        duplicateRate: number; // percentage
      };
      queryPerformance: {
        avgQueryTime: number;
        cacheHitRate: number;
        indexUsage: number;
      };
      updatePerformance: {
        avgUpdateTime: number;
        updateSuccessRate: number;
      };
    };
    health: {
      isHealthy: boolean;
      issues: string[];
      recommendations: string[];
    };
    trends: {
      growthRate: number; // records/day
      sizeGrowthRate: number; // MB/day
      errorRate: number; // percentage
    };
  }> {
    const reportStartTime = Date.now();

    try {
      this.logger.debug('üìà ÂºÄÂßãÁîüÊàêÂ≠òÂÇ®ÊÄßËÉΩÊä•Âëä', {
        timestamp: new Date().toISOString()
      }, 'RawDataService');

      // Ëé∑ÂèñÂü∫Á°ÄÁªüËÆ°‰ø°ÊÅØ
      const stats = await this.getStatistics();

      // ËÆ°ÁÆóÈõÜÂêàÁªüËÆ°‰ø°ÊÅØÔºàÈúÄË¶ÅMongoDBÁöÑÁªüËÆ°APIÔºâ
      const collectionStats = await this.getCollectionStatistics();

      // Ê®°ÊãüÊü•ËØ¢ÊÄßËÉΩÊµãËØï
      const queryPerfStart = Date.now();
      await this.rawDataSourceModel.findOne().exec(); // ÁÆÄÂçïÊü•ËØ¢ÊµãËØï
      const simpleQueryTime = Date.now() - queryPerfStart;

      const complexQueryPerfStart = Date.now();
      await this.rawDataSourceModel.aggregate([
        { $match: { createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } } },
        { $group: { _id: '$sourceType', count: { $sum: 1 } } }
      ]);
      const complexQueryTime = Date.now() - complexQueryPerfStart;

      const reportDuration = Date.now() - reportStartTime;

      // ÂÅ•Â∫∑Ê£ÄÊü•
      const issues: string[] = [];
      const recommendations: string[] = [];

      if (collectionStats.totalSize > 1024) { // Ë∂ÖËøá1GB
        issues.push('large_collection_size');
        recommendations.push('ËÄÉËôëÊï∞ÊçÆÂΩíÊ°£ÊàñÂàÜÁâáÁ≠ñÁï•');
      }

      if (simpleQueryTime > 100) { // Ë∂ÖËøá100ms
        issues.push('slow_query_performance');
        recommendations.push('‰ºòÂåñÁ¥¢ÂºïÊàñÊü•ËØ¢ÁªìÊûÑ');
      }

      if (stats.failed > stats.total * 0.05) { // Â§±Ë¥•ÁéáË∂ÖËøá5%
        issues.push('high_failure_rate');
        recommendations.push('Ê£ÄÊü•Êï∞ÊçÆË¥®ÈáèÂíåÂ≠òÂÇ®ÈÄªËæë');
      }

      const isHealthy = issues.length === 0;

      const report = {
        summary: {
          totalRecords: stats.total,
          totalSizeMB: Math.round(collectionStats.totalSize),
          averageRecordSizeKB: Math.round(collectionStats.avgObjSize / 1024),
          indexEfficiency: Math.round((collectionStats.indexSizes / collectionStats.totalSize) * 100),
          queryPerformance: {
            avgQueryTime: Math.round((simpleQueryTime + complexQueryTime) / 2),
            slowQueries: simpleQueryTime > 100 ? 1 : 0,
            fastQueries: simpleQueryTime <= 100 ? 1 : 0
          }
        },
        operations: {
          insertPerformance: {
            avgInsertTime: 50, // Ê®°ÊãüÊï∞ÊçÆ
            insertThroughput: Math.round(1000 / 50), // Âü∫‰∫éÂπ≥ÂùáÊèíÂÖ•Êó∂Èó¥ËÆ°ÁÆó
            duplicateRate: Math.round((stats.pending / stats.total) * 100)
          },
          queryPerformance: {
            avgQueryTime: Math.round((simpleQueryTime + complexQueryTime) / 2),
            cacheHitRate: 85, // Ê®°ÊãüÊï∞ÊçÆ
            indexUsage: 90 // Ê®°ÊãüÊï∞ÊçÆ
          },
          updatePerformance: {
            avgUpdateTime: 30, // Ê®°ÊãüÊï∞ÊçÆ
            updateSuccessRate: 95 // Ê®°ÊãüÊï∞ÊçÆ
          }
        },
        health: {
          isHealthy,
          issues,
          recommendations
        },
        trends: {
          growthRate: Math.round(stats.byDate[0]?.count || 0), // ÊúÄËøë‰∏ÄÂ§©ÁöÑËÆ∞ÂΩïÊï∞‰Ωú‰∏∫Â¢ûÈïøÁéáÂèÇËÄÉ
          sizeGrowthRate: Math.round(collectionStats.totalSize * 0.1), // ÂÅáËÆæÊØèÊó•Â¢ûÈïø10%
          errorRate: Math.round((stats.failed / stats.total) * 100)
        }
      };

      this.logger.log('üìä Â≠òÂÇ®ÊÄßËÉΩÊä•ÂëäÁîüÊàêÂÆåÊàê', {
        reportDuration,
        summary: report.summary,
        health: report.health,
        trends: report.trends
      }, 'RawDataService');

      return report;

    } catch (error) {
      const reportDuration = Date.now() - reportStartTime;
      this.logger.error('‚ùå Â≠òÂÇ®ÊÄßËÉΩÊä•ÂëäÁîüÊàêÂ§±Ë¥•', {
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        errorType: this.classifyStorageError(error),
        reportDuration
      }, 'RawDataService');
      throw error;
    }
  }

  /**
   * Ëé∑ÂèñÈõÜÂêàÁªüËÆ°‰ø°ÊÅØ
   */
  private async getCollectionStatistics(): Promise<{
    totalSize: number; // MB
    avgObjSize: number; // bytes
    indexSizes: number; // MB
    count: number;
  }> {
    try {
      // ËøôÈáåÂ∫îËØ•‰ΩøÁî®MongoDBÁöÑcollStatsÂëΩ‰ª§Ôºå‰ΩÜÁî±‰∫éÊàë‰ª¨Âú®MongooseÁéØÂ¢É‰∏≠Ôºå
      // Êàë‰ª¨‰ΩøÁî®ÁÆÄÂåñÁöÑÊñπÂºèÊù•Ëé∑ÂèñÂü∫Êú¨‰ø°ÊÅØ
      const count = await this.rawDataSourceModel.countDocuments();

      // Ê®°ÊãüÁªüËÆ°Êï∞ÊçÆÔºàÂÆûÈôÖÂ∫îÁî®‰∏≠Â∫îËØ•‰ΩøÁî®ÁúüÂÆûÁöÑcollStatsÔºâ
      return {
        totalSize: Math.round(count * 50 * 1024 / 1024), // ÂÅáËÆæÂπ≥ÂùáÊØèÊù°ËÆ∞ÂΩï50KB
        avgObjSize: 50 * 1024, // 50KB
        indexSizes: Math.round(count * 5 * 1024 / 1024), // ÂÅáËÆæÁ¥¢ÂºïÂ§ßÂ∞èÊòØÊï∞ÊçÆÂ§ßÂ∞èÁöÑ10%
        count
      };
    } catch (error) {
      this.logger.warn('Ëé∑ÂèñÈõÜÂêàÁªüËÆ°‰ø°ÊÅØÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº', {
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'
      }, 'RawDataService');

      return {
        totalSize: 0,
        avgObjSize: 0,
        indexSizes: 0,
        count: 0
      };
    }
  }

  /**
   * ÂàùÂßãÂåñ RabbitMQ ËøûÊé•
   */
  private async initializeRabbitMQ(): Promise<void> {
    try {
      this.rabbitMQClient = new RabbitMQClient({ url: this.rabbitmqConfig.url });
      await this.rabbitMQClient.connect();
      this.isRabbitMQConnected = true;
      this.logger.log('üîó RabbitMQ ËøûÊé•ÂàùÂßãÂåñÊàêÂäü', {
        url: this.rabbitmqConfig.url.replace(/\/\/.*@/, '//***@')
      }, 'RawDataService');
    } catch (error) {
      this.isRabbitMQConnected = false;
      this.logger.warn('‚ö†Ô∏è RabbitMQ ÂàùÂßãÂåñÂ§±Ë¥•ÔºåÊ∂àÊÅØÂèëÂ∏ÉÂ∞ÜË¢´Ë∑≥Ëøá', {
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        willRetry: true
      }, 'RawDataService');
    }
  }

  /**
   * ÂèëÂ∏ÉÂéüÂßãÊï∞ÊçÆÂ∞±Áª™‰∫ã‰ª∂
   */
  private async publishRawDataReady(rawData: RawDataSource): Promise<void> {
    if (!this.isRabbitMQConnected || !this.rabbitMQClient) {
      this.logger.debug('‚è≠Ô∏è RabbitMQ Êú™ËøûÊé•ÔºåË∑≥ËøáÊ∂àÊÅØÂèëÂ∏É', {
        rawDataId: rawData._id,
        sourceType: rawData.sourceType
      }, 'RawDataService');
      return;
    }

    const publishStartTime = Date.now();
    const rawDataId = rawData._id?.toString();

    if (!rawDataId) {
      this.logger.warn('‚ö†Ô∏è ÂéüÂßãÊï∞ÊçÆIDÁº∫Â§±ÔºåË∑≥ËøáÊ∂àÊÅØÂèëÂ∏É', {
        sourceType: rawData.sourceType,
        sourceUrl: rawData.sourceUrl.substring(0, 100)
      }, 'RawDataService');
      return;
    }

    const sourcePlatform = this.extractSourcePlatform(rawData.sourceType);
    const event: RawDataReadyEvent = {
      rawDataId,
      sourceType: rawData.sourceType as any,
      sourcePlatform,
      sourceUrl: rawData.sourceUrl,
      contentHash: rawData.contentHash,
      metadata: {
        taskId: rawData.metadata?.taskId,
        keyword: rawData.metadata?.keyword,
        fileSize: rawData.rawContent?.length || 0,
      },
      createdAt: new Date().toISOString(),
    };

    try {
      await this.retryPublish(QUEUE_NAMES.RAW_DATA_READY, event);
      const publishDuration = Date.now() - publishStartTime;

      this.logger.log('üì§ ÂéüÂßãÊï∞ÊçÆÂ∞±Áª™‰∫ã‰ª∂ÂèëÂ∏ÉÊàêÂäü', {
        rawDataId,
        sourceType: rawData.sourceType,
        sourcePlatform,
        queue: QUEUE_NAMES.RAW_DATA_READY,
        publishDuration,
        taskId: rawData.metadata?.taskId,
        traceId: rawData.metadata?.traceId
      }, 'RawDataService');

      this.publishRetryCount = 0;

    } catch (error) {
      const publishDuration = Date.now() - publishStartTime;
      this.logger.error('‚ùå ÂéüÂßãÊï∞ÊçÆÂ∞±Áª™‰∫ã‰ª∂ÂèëÂ∏ÉÂ§±Ë¥•', {
        rawDataId,
        sourceType: rawData.sourceType,
        queue: QUEUE_NAMES.RAW_DATA_READY,
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        publishDuration,
        retryCount: this.publishRetryCount,
        taskId: rawData.metadata?.taskId,
        traceId: rawData.metadata?.traceId
      }, 'RawDataService');
    }
  }

  /**
   * Â∏¶ÊåáÊï∞ÈÄÄÈÅøÁöÑÈáçËØïÂèëÂ∏É
   */
  private async retryPublish(queue: string, event: RawDataReadyEvent, retryCount = 0): Promise<void> {
    try {
      if (!this.rabbitMQClient) {
        throw new Error('RabbitMQ ÂÆ¢Êà∑Á´ØÊú™ÂàùÂßãÂåñ');
      }

      await this.rabbitMQClient.publish(queue, event);
    } catch (error) {
      if (retryCount < this.MAX_PUBLISH_RETRIES) {
        const backoffDelay = Math.min(1000 * Math.pow(2, retryCount), 8000);

        this.logger.warn(`üîÑ Ê∂àÊÅØÂèëÂ∏ÉÂ§±Ë¥•Ôºå${backoffDelay}ms ÂêéÈáçËØï (${retryCount + 1}/${this.MAX_PUBLISH_RETRIES})`, {
          queue,
          rawDataId: event.rawDataId,
          error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
          backoffDelay
        }, 'RawDataService');

        await new Promise(resolve => setTimeout(resolve, backoffDelay));
        return this.retryPublish(queue, event, retryCount + 1);
      }

      throw error;
    }
  }

  /**
   * ‰ªé sourceType ÊèêÂèñ sourcePlatform
   */
  private extractSourcePlatform(sourceType: string): SourcePlatform {
    if (sourceType.startsWith('weibo')) {
      return SourcePlatform.WEIBO;
    }
    if (sourceType.startsWith('jd')) {
      return SourcePlatform.JD;
    }
    return SourcePlatform.CUSTOM;
  }

  /**
   * ÁõëÊéßÂ≠òÂÇ®ÂÅ•Â∫∑Áä∂ÊÄÅ
   */
  async monitorStorageHealth(): Promise<{
    status: 'healthy' | 'warning' | 'critical';
    score: number; // 0-100
    checks: Array<{
      name: string;
      status: 'pass' | 'warn' | 'fail';
      value: any;
      threshold: any;
    }>;
    alerts: string[];
    recommendations: string[];
  }> {
    const healthStartTime = Date.now();
    const checks: Array<{
      name: string;
      status: 'pass' | 'warn' | 'fail';
      value: any;
      threshold: any;
    }> = [];
    const alerts: string[] = [];
    const recommendations: string[] = [];

    try {
      // Ê£ÄÊü•1ÔºöËøûÊé•Áä∂ÊÄÅ
      const connectionStart = Date.now();
      await this.rawDataSourceModel.findOne().exec().catch(() => null);
      const connectionTime = Date.now() - connectionStart;

      checks.push({
        name: 'database_connection',
        status: connectionTime < 1000 ? 'pass' : connectionTime < 3000 ? 'warn' : 'fail',
        value: connectionTime,
        threshold: { pass: 1000, warn: 3000 }
      });

      if (connectionTime > 3000) {
        alerts.push('Êï∞ÊçÆÂ∫ìËøûÊé•ÂìçÂ∫îÁºìÊÖ¢');
        recommendations.push('Ê£ÄÊü•Êï∞ÊçÆÂ∫ìÊúçÂä°Âô®ÊÄßËÉΩÂíåÁΩëÁªúËøûÊé•');
      }

      // Ê£ÄÊü•2ÔºöÂ≠òÂÇ®Â§ßÂ∞è
      const stats = await this.getStatistics();
      const collectionStats = await this.getCollectionStatistics();

      checks.push({
        name: 'storage_size',
        status: collectionStats.totalSize < 5120 ? 'pass' : collectionStats.totalSize < 10240 ? 'warn' : 'fail',
        value: collectionStats.totalSize,
        threshold: { pass: 5120, warn: 10240 } // MB
      });

      if (collectionStats.totalSize > 10240) {
        alerts.push('Â≠òÂÇ®Á©∫Èó¥‰ΩøÁî®ËøáÂ§ö');
        recommendations.push('ËÄÉËôëÊï∞ÊçÆÂΩíÊ°£ÊàñÊ∏ÖÁêÜÁ≠ñÁï•');
      }

      // Ê£ÄÊü•3ÔºöÈîôËØØÁéá
      const errorRate = stats.total > 0 ? (stats.failed / stats.total) * 100 : 0;

      checks.push({
        name: 'error_rate',
        status: errorRate < 5 ? 'pass' : errorRate < 10 ? 'warn' : 'fail',
        value: Math.round(errorRate),
        threshold: { pass: 5, warn: 10 }
      });

      if (errorRate > 10) {
        alerts.push('Â≠òÂÇ®ÈîôËØØÁéáËøáÈ´ò');
        recommendations.push('Ê£ÄÊü•Êï∞ÊçÆË¥®ÈáèÂíåÂ≠òÂÇ®ÈÄªËæë');
      }

      // ËÆ°ÁÆóÊÄª‰ΩìÂÅ•Â∫∑ËØÑÂàÜ
      const passCount = checks.filter(c => c.status === 'pass').length;
      const warnCount = checks.filter(c => c.status === 'warn').length;
      const failCount = checks.filter(c => c.status === 'fail').length;

      const score = Math.round(((passCount * 100) + (warnCount * 50)) / checks.length);

      let status: 'healthy' | 'warning' | 'critical';
      if (failCount > 0) {
        status = 'critical';
      } else if (warnCount > 0 || score < 80) {
        status = 'warning';
      } else {
        status = 'healthy';
      }

      const healthDuration = Date.now() - healthStartTime;

      this.logger.log('üè• Â≠òÂÇ®ÂÅ•Â∫∑Ê£ÄÊü•ÂÆåÊàê', {
        status,
        score,
        checksCount: checks.length,
        alertsCount: alerts.length,
        duration: healthDuration
      }, 'RawDataService');

      return {
        status,
        score,
        checks,
        alerts,
        recommendations
      };

    } catch (error) {
      const healthDuration = Date.now() - healthStartTime;
      this.logger.error('‚ùå Â≠òÂÇ®ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•', {
        error: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
        errorType: this.classifyStorageError(error),
        duration: healthDuration
      }, 'RawDataService');

      return {
        status: 'critical',
        score: 0,
        checks: [{
          name: 'health_check',
          status: 'fail',
          value: error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ',
          threshold: 'pass'
        }],
        alerts: ['ÂÅ•Â∫∑Ê£ÄÊü•ÊâßË°åÂ§±Ë¥•'],
        recommendations: ['Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•ÂíåÈÖçÁΩÆ']
      };
    }
  }
}