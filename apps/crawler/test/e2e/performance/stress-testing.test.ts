import { Test, TestingModule } from '@nestjs/testing';
import { ConfigModule } from '@nestjs/config';
import { Logger } from '@pro/logger';
import {
  WeiboSearchCrawlerService,
  EnhancedSubTaskMessage,
  MultiModeCrawlResult
} from '../../../src/weibo/search-crawler.service';
import {
  TEST_CONFIG,
  TestStateManager,
  TestUtils,
  MockWeiboAccountService,
  MockBrowserService,
  MockRawDataService,
  MockRobotsService,
  MockRequestMonitorService
} from '../setup';

/**
 * ÊÄßËÉΩÂéãÂäõÊµãËØïÂ•ó‰ª∂ - Êï∞Â≠óÊó∂‰ª£ÁöÑÁ≥ªÁªüÊûÅÈôêÈ™åËØÅËâ∫ÊúØÂìÅ
 * ÊµãËØïÁ≥ªÁªüÂú®È´òÂπ∂Âèë„ÄÅÂ§ßÊï∞ÊçÆÈáè‰∏ãÁöÑÁ®≥ÂÆöÊÄßÂíåÊÄßËÉΩË°®Áé∞
 */

describe('ÊÄßËÉΩÂéãÂäõÊµãËØïÂ•ó‰ª∂', () => {
  let crawlerService: WeiboSearchCrawlerService;
  let module: TestingModule;
  let testSessionId: string;

  // ÊÄßËÉΩÁõëÊéßÊï∞ÊçÆ
  let performanceMetrics: {
    cpuUsage: number[];
    memoryUsage: number[];
    responseTime: number[];
    throughput: number[];
    errorRate: number[];
    concurrency: number[];
  };

  beforeAll(async () => {
    testSessionId = TestStateManager.getInstance().createTestSession('ÊÄßËÉΩÂéãÂäõÊµãËØïÂ•ó‰ª∂');

    // ÂàùÂßãÂåñÊÄßËÉΩÁõëÊéß
    performanceMetrics = {
      cpuUsage: [],
      memoryUsage: [],
      responseTime: [],
      throughput: [],
      errorRate: [],
      concurrency: []
    };

    // ÂàõÂª∫ÊµãËØïÊ®°Âùó
    module = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot({
          isGlobal: true,
          load: [() => ({
            NODE_ENV: 'test',
            CRAWLER_CONFIG: {
              maxPages: 10,
              requestDelay: { min: 50, max: 200 },
              pageTimeout: 15000
            },
            WEIBO_CONFIG: {
              baseUrl: 'https://weibo.com',
              searchUrl: 'https://weibo.com/search'
            }
          })]
        })
      ],
      providers: [
        Logger,
        {
          provide: WeiboSearchCrawlerService,
          useFactory: () => ({
            multiModeCrawl: jest.fn().mockImplementation(async (message: EnhancedSubTaskMessage): Promise<MultiModeCrawlResult> => {
              const startTime = Date.now();

              // Ê®°Êãü‰∏çÂêåÁöÑÂ§ÑÁêÜÊó∂Èó¥
              const baseProcessingTime = 2000;
              const variability = Math.random() * 3000;
              const processingTime = baseProcessingTime + variability;

              await TestUtils.sleep(processingTime);

              // Ê®°ÊãüÂÅ∂Â∞îÁöÑÂ§±Ë¥•
              const success = Math.random() > (TEST_CONFIG.errorInjection.networkFailureRate + 0.1);

              const duration = Date.now() - startTime;

              if (success) {
                // ËÆ∞ÂΩïÊàêÂäüÊåáÊ†á
                performanceMetrics.responseTime.push(duration);
                performanceMetrics.throughput.push((Math.random() * 5 + 1)); // 1-6 MB/s

                return {
                  searchResult: {
                    success: true,
                    pageCount: Math.floor(Math.random() * 10) + 1
                  },
                  noteDetails: [],
                  creatorDetails: [],
                  comments: [],
                  mediaDownloads: [],
                  crawlMetrics: {
                    totalPages: Math.floor(Math.random() * 10) + 1,
                    successfulPages: Math.floor(Math.random() * 10) + 1,
                    failedPages: 0,
                    skippedPages: 0,
                    totalRequests: Math.floor(Math.random() * 20) + 10,
                    averagePageLoadTime: 800 + Math.random() * 1200,
                    totalDataSize: Math.floor(Math.random() * 5 * 1024 * 1024), // 0-5MB
                    notesCrawled: 0,
                    detailsCrawled: 0,
                    creatorsCrawled: 0,
                    commentsCrawled: 0,
                    mediaFilesDownloaded: 0,
                    commentDepthReached: 0,
                    totalDuration: duration,
                    throughputMBps: (Math.random() * 5 + 1),
                    requestsPerSecond: Math.random() * 5 + 2,
                    errorRate: 0,
                    memoryUsage: Math.floor(Math.random() * 100 + 50), // 50-150MB
                    cpuUsage: Math.floor(Math.random() * 60 + 20) // 20-80%
                  }
                };
              } else {
                // ËÆ∞ÂΩïÂ§±Ë¥•ÊåáÊ†á
                performanceMetrics.errorRate.push(1);

                return {
                  searchResult: {
                    success: false,
                    pageCount: 0,
                    error: 'Ê®°ÊãüÂéãÂäõÊµãËØïÂ§±Ë¥•'
                  },
                  noteDetails: [],
                  creatorDetails: [],
                  comments: [],
                  mediaDownloads: [],
                  crawlMetrics: {
                    totalPages: 0,
                    successfulPages: 0,
                    failedPages: 1,
                    skippedPages: 0,
                    totalRequests: 1,
                    averagePageLoadTime: 0,
                    totalDataSize: 0,
                    notesCrawled: 0,
                    detailsCrawled: 0,
                    creatorsCrawled: 0,
                    commentsCrawled: 0,
                    mediaFilesDownloaded: 0,
                    commentDepthReached: 0,
                    totalDuration: duration,
                    throughputMBps: 0,
                    requestsPerSecond: 0,
                    errorRate: 100,
                    memoryUsage: 30,
                    cpuUsage: 10
                  }
                };
              }
            })
          })
        }
      ]
    }).compile();

    crawlerService = module.get(WeiboSearchCrawlerService);
  });

  afterAll(async () => {
    TestStateManager.getInstance().endTestSession(testSessionId);
    await module.close();
  });

  describe('Âü∫ÂáÜÊÄßËÉΩÊµãËØï', () => {
    it('Â∫îËØ•Êª°Ë∂≥Âü∫Á°ÄÊÄßËÉΩÂü∫ÂáÜ', async () => {
      const testMessage = TestUtils.createEnhancedTestSubTaskMessage({
        keyword: 'Âü∫ÂáÜÊµãËØï',
        taskId: 7001,
        crawlModes: ['search']
      });

      const startTime = Date.now();
      const result = await crawlerService.multiModeCrawl(testMessage);
      const duration = Date.now() - startTime;

      // Âü∫ÂáÜÊÄßËÉΩË¶ÅÊ±Ç
      expect(duration).toBeLessThan(TEST_CONFIG.performance.maxExecutionTime);
      expect(result.crawlMetrics.requestsPerSecond).toBeGreaterThan(1);
      expect(result.crawlMetrics.throughputMBps).toBeGreaterThan(0.1);
      expect(result.crawlMetrics.memoryUsage).toBeLessThan(TEST_CONFIG.performance.memoryThreshold / 1024 / 1024);
      expect(result.crawlMetrics.cpuUsage).toBeLessThan(TEST_CONFIG.performance.cpuThreshold);

      console.log(`‚úÖ Âü∫ÂáÜÊÄßËÉΩÊµãËØïÂÆåÊàê - ÂìçÂ∫îÊó∂Èó¥: ${duration}ms, RPS: ${result.crawlMetrics.requestsPerSecond}, ÂêûÂêêÈáè: ${result.crawlMetrics.throughputMBps}MB/s`);
    });

    it('Â∫îËØ•Âú®Ê†áÂáÜË¥üËΩΩ‰∏ã‰øùÊåÅÁ®≥ÂÆöÊÄßËÉΩ', async () => {
      const standardLoad = 5;
      const messages = Array.from({ length: standardLoad }, (_, i) =>
        TestUtils.createEnhancedTestSubTaskMessage({
          keyword: `Ê†áÂáÜË¥üËΩΩ_${i + 1}`,
          taskId: 7100 + i,
          crawlModes: ['search']
        })
      );

      const startTime = Date.now();
      const results = await Promise.allSettled(
        messages.map(message => crawlerService.multiModeCrawl(message))
      );
      const totalDuration = Date.now() - startTime;

      // ÂàÜÊûêÊÄßËÉΩÊåáÊ†á
      const successfulResults = results.filter(r => r.status === 'fulfilled') as any[];
      const successRate = (successfulResults.length / standardLoad) * 100;

      let avgResponseTime = 0;
      let avgThroughput = 0;
      let avgMemoryUsage = 0;
      let avgCpuUsage = 0;

      successfulResults.forEach(result => {
        const metrics = result.value.crawlMetrics;
        avgResponseTime += metrics.totalDuration;
        avgThroughput += metrics.throughputMBps;
        avgMemoryUsage += metrics.memoryUsage;
        avgCpuUsage += metrics.cpuUsage;
      });

      if (successfulResults.length > 0) {
        avgResponseTime /= successfulResults.length;
        avgThroughput /= successfulResults.length;
        avgMemoryUsage /= successfulResults.length;
        avgCpuUsage /= successfulResults.length;
      }

      // ÊÄßËÉΩË¶ÅÊ±Ç
      expect(successRate).toBeGreaterThan(90);
      expect(avgResponseTime).toBeLessThan(TEST_CONFIG.performance.maxExecutionTime);
      expect(avgThroughput).toBeGreaterThan(0.5);
      expect(avgMemoryUsage).toBeLessThan(200);
      expect(avgCpuUsage).toBeLessThan(70);

      console.log(`‚úÖ Ê†áÂáÜË¥üËΩΩÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, Âπ≥ÂùáÂìçÂ∫îÊó∂Èó¥: ${avgResponseTime.toFixed(0)}ms, Âπ≥ÂùáÂêûÂêêÈáè: ${avgThroughput.toFixed(2)}MB/s`);
    });
  });

  describe('Âπ∂ÂèëÂéãÂäõÊµãËØï', () => {
    it('Â∫îËØ•Âú®È´òÂπ∂Âèë‰∏ã‰øùÊåÅÁ≥ªÁªüÁ®≥ÂÆö', async () => {
      const highConcurrency = 10;
      const messages = Array.from({ length: highConcurrency }, (_, i) =>
        TestUtils.createEnhancedTestSubTaskMessage({
          keyword: `È´òÂπ∂Âèë_${i + 1}`,
          taskId: 7200 + i,
          crawlModes: ['search', 'detail']
        })
      );

      console.log(`üöÄ ÂºÄÂßãÈ´òÂπ∂ÂèëÊµãËØï - Âπ∂ÂèëÊï∞: ${highConcurrency}`);
      const startTime = Date.now();

      const results = await Promise.allSettled(
        messages.map(message => crawlerService.multiModeCrawl(message))
      );

      const totalDuration = Date.now() - startTime;

      // ÂàÜÊûêÂπ∂ÂèëÊÄßËÉΩ
      const successfulResults = results.filter(r => r.status === 'fulfilled') as any[];
      const failedResults = results.filter(r => r.status === 'rejected');

      const successRate = (successfulResults.length / highConcurrency) * 100;
      const concurrency = successfulResults.length / (totalDuration / 1000); // Âπ∂ÂèëÂ∫¶

      let totalThroughput = 0;
      let maxMemoryUsage = 0;
      let maxCpuUsage = 0;

      successfulResults.forEach(result => {
        const metrics = result.value.crawlMetrics;
        totalThroughput += metrics.throughputMBps;
        maxMemoryUsage = Math.max(maxMemoryUsage, metrics.memoryUsage);
        maxCpuUsage = Math.max(maxCpuUsage, metrics.cpuUsage);
      });

      const avgThroughput = totalThroughput / successfulResults.length;

      // È´òÂπ∂ÂèëÊÄßËÉΩË¶ÅÊ±Ç
      expect(successRate).toBeGreaterThan(80); // È´òÂπ∂Âèë‰∏ãÂÖÅËÆ∏Êõ¥È´òÁöÑÂ§±Ë¥•Áéá
      expect(concurrency).toBeGreaterThan(5);
      expect(avgThroughput).toBeGreaterThan(0.3);
      expect(maxMemoryUsage).toBeLessThan(300);
      expect(maxCpuUsage).toBeLessThan(85);

      // ËÆ∞ÂΩïÊÄßËÉΩÊåáÊ†á
      performanceMetrics.concurrency.push(concurrency);
      performanceMetrics.errorRate.push(failedResults.length / highConcurrency);

      console.log(`‚úÖ È´òÂπ∂ÂèëÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, Âπ∂ÂèëÂ∫¶: ${concurrency.toFixed(1)}, Âπ≥ÂùáÂêûÂêêÈáè: ${avgThroughput.toFixed(2)}MB/s`);
    });

    it('Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜÂ≥∞ÂÄºË¥üËΩΩ', async () => {
      const peakLoad = 15;
      const burstDuration = 10000; // 10ÁßíÂ≥∞ÂÄºË¥üËΩΩ

      console.log(`‚ö° ÂºÄÂßãÂ≥∞ÂÄºË¥üËΩΩÊµãËØï - Â≥∞ÂÄºÊï∞: ${peakLoad}, ÊåÅÁª≠Êó∂Èó¥: ${burstDuration}ms`);

      const startTime = Date.now();
      let completedTasks = 0;
      let failedTasks = 0;

      // ÂàÜÊâπÂèëÈÄÅ‰ªªÂä°‰ª•Ê®°ÊãüÂ≥∞ÂÄº
      const batches = [
        messages.slice(0, 5),
        messages.slice(5, 10),
        messages.slice(10, 15)
      ];

      for (let i = 0; i < batches.length; i++) {
        const batchStartTime = Date.now();

        const batchPromises = batches[i].map(message =>
          crawlerService.multiModeCrawl(message)
            .then(result => {
              completedTasks++;
              return result;
            })
            .catch(error => {
              failedTasks++;
              throw error;
            })
        );

        await Promise.allSettled(batchPromises);

        const batchDuration = Date.now() - batchStartTime;

        // ÊâπÊ¨°Èó¥Áü≠ÊöÇÂª∂Ëøü
        if (i < batches.length - 1) {
          await TestUtils.sleep(1000);
        }
      }

      const totalDuration = Date.now() - startTime;
      const throughput = completedTasks / (totalDuration / 1000); // ‰ªªÂä°/Áßí
      const successRate = (completedTasks / peakLoad) * 100;

      // Â≥∞ÂÄºË¥üËΩΩÊÄßËÉΩË¶ÅÊ±Ç
      expect(successRate).toBeGreaterThan(75);
      expect(throughput).toBeGreaterThan(0.5);
      expect(totalDuration).toBeLessThan(burstDuration * 2);

      console.log(`‚úÖ Â≥∞ÂÄºË¥üËΩΩÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, ÂêûÂêêÈáè: ${throughput.toFixed(2)}‰ªªÂä°/Áßí, ÊÄªËÄóÊó∂: ${totalDuration}ms`);
    });
  });

  describe('ÂÜÖÂ≠òÂíåCPUÂéãÂäõÊµãËØï', () => {
    it('Â∫îËØ•Âú®ÂÜÖÂ≠òÂéãÂäõ‰∏ãÊ≠£Â∏∏Â∑•‰Ωú', async () => {
      const memoryPressureTasks = 8;
      const messages = Array.from({ length: memoryPressureTasks }, (_, i) =>
        TestUtils.createEnhancedTestSubTaskMessage({
          keyword: `ÂÜÖÂ≠òÂéãÂäõ_${i + 1}`,
          taskId: 7300 + i,
          crawlModes: ['search', 'detail', 'creator'],
          enableDetailCrawl: true,
          enableCreatorCrawl: true
        })
      );

      console.log(`üíæ ÂºÄÂßãÂÜÖÂ≠òÂéãÂäõÊµãËØï - ‰ªªÂä°Êï∞: ${memoryPressureTasks}`);

      const initialMemory = process.memoryUsage().heapUsed / 1024 / 1024; // MB
      const startTime = Date.now();

      const results = await Promise.allSettled(
        messages.map(message => crawlerService.multiModeCrawl(message))
      );

      const finalMemory = process.memoryUsage().heapUsed / 1024 / 1024; // MB
      const memoryIncrease = finalMemory - initialMemory;
      const duration = Date.now() - startTime;

      const successfulResults = results.filter(r => r.status === 'fulfilled') as any[];
      const successRate = (successfulResults.length / memoryPressureTasks) * 100;

      // ÂÜÖÂ≠òÂéãÂäõÊµãËØïË¶ÅÊ±Ç
      expect(successRate).toBeGreaterThan(85);
      expect(memoryIncrease).toBeLessThan(200); // ÂÜÖÂ≠òÂ¢ûÈïø‰∏çË∂ÖËøá200MB
      expect(finalMemory).toBeLessThan(TEST_CONFIG.performance.memoryThreshold / 1024 / 1024);

      console.log(`‚úÖ ÂÜÖÂ≠òÂéãÂäõÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, ÂÜÖÂ≠òÂ¢ûÈïø: ${memoryIncrease.toFixed(1)}MB, ÊúÄÁªàÂÜÖÂ≠ò: ${finalMemory.toFixed(1)}MB`);
    });

    it('Â∫îËØ•Âú®CPUÂéãÂäõ‰∏ã‰øùÊåÅÂìçÂ∫î', async () => {
      const cpuPressureTasks = 6;
      const messages = Array.from({ length: cpuPressureTasks }, (_, i) =>
        TestUtils.createEnhancedTestSubTaskMessage({
          keyword: `CPUÂéãÂäõ_${i + 1}`,
          taskId: 7400 + i,
          crawlModes: ['search', 'detail', 'creator', 'comment'],
          enableCommentCrawl: true,
          maxCommentDepth: 3
        })
      );

      console.log(`üî• ÂºÄÂßãCPUÂéãÂäõÊµãËØï - ‰ªªÂä°Êï∞: ${cpuPressureTasks}`);

      const startTime = Date.now();

      // ÁõëÊéßCPU‰ΩøÁî®Áéá
      const cpuMonitoringInterval = setInterval(() => {
        const cpuUsage = Math.random() * 40 + 40; // Ê®°Êãü40-80% CPU‰ΩøÁî®Áéá
        performanceMetrics.cpuUsage.push(cpuUsage);
      }, 1000);

      const results = await Promise.allSettled(
        messages.map(message => crawlerService.multiModeCrawl(message))
      );

      clearInterval(cpuMonitoringInterval);
      const duration = Date.now() - startTime;

      const successfulResults = results.filter(r => r.status === 'fulfilled') as any[];
      const successRate = (successfulResults.length / cpuPressureTasks) * 100;

      let avgCpuUsage = 0;
      if (performanceMetrics.cpuUsage.length > 0) {
        avgCpuUsage = performanceMetrics.cpuUsage.reduce((sum, usage) => sum + usage, 0) / performanceMetrics.cpuUsage.length;
      }

      // CPUÂéãÂäõÊµãËØïË¶ÅÊ±Ç
      expect(successRate).toBeGreaterThan(80);
      expect(avgCpuUsage).toBeLessThan(80);
      expect(duration).toBeLessThan(TEST_CONFIG.performance.maxExecutionTime * 2);

      console.log(`‚úÖ CPUÂéãÂäõÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, Âπ≥ÂùáCPU‰ΩøÁî®Áéá: ${avgCpuUsage.toFixed(1)}%, ËÄóÊó∂: ${duration}ms`);
    });
  });

  describe('ÈïøÊó∂Èó¥Á®≥ÂÆöÊÄßÊµãËØï', () => {
    it('Â∫îËØ•Âú®ÈïøÊó∂Èó¥ËøêË°å‰∏ã‰øùÊåÅÁ®≥ÂÆö', async () => {
      const longRunningDuration = 30000; // 30Áßí
      const taskInterval = 2000; // ÊØè2Áßí‰∏Ä‰∏™‰ªªÂä°
      const maxTasks = Math.floor(longRunningDuration / taskInterval);

      console.log(`‚è∞ ÂºÄÂßãÈïøÊó∂Èó¥Á®≥ÂÆöÊÄßÊµãËØï - ÊåÅÁª≠Êó∂Èó¥: ${longRunningDuration}ms, È¢ÑÊúü‰ªªÂä°Êï∞: ${maxTasks}`);

      const startTime = Date.now();
      const results: any[] = [];
      let taskCounter = 0;

      // ÊåÅÁª≠ÂèëÈÄÅ‰ªªÂä°
      const intervalId = setInterval(async () => {
        if (taskCounter >= maxTasks) {
          clearInterval(intervalId);
          return;
        }

        const message = TestUtils.createEnhancedTestSubTaskMessage({
          keyword: `ÈïøÊó∂Èó¥_${taskCounter + 1}`,
          taskId: 7500 + taskCounter,
          crawlModes: ['search']
        });

        try {
          const result = await crawlerService.multiModeCrawl(message);
          results.push({ status: 'fulfilled', value: result, timestamp: Date.now() });
        } catch (error) {
          results.push({ status: 'rejected', reason: error, timestamp: Date.now() });
        }

        taskCounter++;
      }, taskInterval);

      // Á≠âÂæÖÊâÄÊúâ‰ªªÂä°ÂÆåÊàê
      await new Promise(resolve => setTimeout(resolve, longRunningDuration + 5000));

      const totalDuration = Date.now() - startTime;

      // ÂàÜÊûêÈïøÊúüÁ®≥ÂÆöÊÄß
      const successfulResults = results.filter(r => r.status === 'fulfilled');
      const failedResults = results.filter(r => r.status === 'rejected');

      const successRate = (successfulResults.length / results.length) * 100;
      const actualThroughput = results.length / (totalDuration / 1000);

      // ÊÄßËÉΩË°∞ÂáèÂàÜÊûê
      const firstHalf = successfulResults.slice(0, Math.floor(successfulResults.length / 2));
      const secondHalf = successfulResults.slice(Math.floor(successfulResults.length / 2));

      const firstHalfAvgResponse = firstHalf.reduce((sum, r) => sum + r.value.crawlMetrics.totalDuration, 0) / firstHalf.length;
      const secondHalfAvgResponse = secondHalf.reduce((sum, r) => sum + r.value.crawlMetrics.totalDuration, 0) / secondHalf.length;

      const performanceDegradation = ((secondHalfAvgResponse - firstHalfAvgResponse) / firstHalfAvgResponse) * 100;

      // ÈïøÊó∂Èó¥Á®≥ÂÆöÊÄßË¶ÅÊ±Ç
      expect(successRate).toBeGreaterThan(90);
      expect(actualThroughput).toBeGreaterThan(0.4);
      expect(Math.abs(performanceDegradation)).toBeLessThan(50); // ÊÄßËÉΩË°∞Âáè‰∏çË∂ÖËøá50%

      console.log(`‚úÖ ÈïøÊó∂Èó¥Á®≥ÂÆöÊÄßÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, ÂÆûÈôÖÂêûÂêêÈáè: ${actualThroughput.toFixed(2)}‰ªªÂä°/Áßí, ÊÄßËÉΩË°∞Âáè: ${performanceDegradation.toFixed(1)}%`);
    });
  });

  describe('ÊÄßËÉΩÂõûÂΩíÊµãËØï', () => {
    it('Â∫îËØ•ÊÄßËÉΩÊåáÊ†á‰øùÊåÅÂú®Âü∫ÂáÜÁ∫ø‰ª•‰∏ä', async () => {
      // Âü∫ÂáÜÊÄßËÉΩÊåáÊ†á
      const baselineMetrics = {
        avgResponseTime: 5000,
        minThroughput: 0.5,
        maxMemoryUsage: 150,
        maxCpuUsage: 70,
        minSuccessRate: 90
      };

      const testTasks = 10;
      const messages = Array.from({ length: testTasks }, (_, i) =>
        TestUtils.createEnhancedTestSubTaskMessage({
          keyword: `ÂõûÂΩíÊµãËØï_${i + 1}`,
          taskId: 7600 + i,
          crawlModes: ['search', 'detail']
        })
      );

      const results = await Promise.allSettled(
        messages.map(message => crawlerService.multiModeCrawl(message))
      );

      const successfulResults = results.filter(r => r.status === 'fulfilled') as any[];
      const successRate = (successfulResults.length / testTasks) * 100;

      // ËÆ°ÁÆóÂÆûÈôÖÊåáÊ†á
      let totalResponseTime = 0;
      let totalThroughput = 0;
      let maxMemoryUsage = 0;
      let maxCpuUsage = 0;

      successfulResults.forEach(result => {
        const metrics = result.value.crawlMetrics;
        totalResponseTime += metrics.totalDuration;
        totalThroughput += metrics.throughputMBps;
        maxMemoryUsage = Math.max(maxMemoryUsage, metrics.memoryUsage);
        maxCpuUsage = Math.max(maxCpuUsage, metrics.cpuUsage);
      });

      const avgResponseTime = totalResponseTime / successfulResults.length;
      const avgThroughput = totalThroughput / successfulResults.length;

      // ÊÄßËÉΩÂõûÂΩíÊ£ÄÊü•
      expect(successRate).toBeGreaterThanOrEqual(baselineMetrics.minSuccessRate);
      expect(avgResponseTime).toBeLessThanOrEqual(baselineMetrics.avgResponseTime);
      expect(avgThroughput).toBeGreaterThanOrEqual(baselineMetrics.minThroughput);
      expect(maxMemoryUsage).toBeLessThanOrEqual(baselineMetrics.maxMemoryUsage);
      expect(maxCpuUsage).toBeLessThanOrEqual(baselineMetrics.maxCpuUsage);

      console.log(`‚úÖ ÊÄßËÉΩÂõûÂΩíÊµãËØïÂÆåÊàê - ÊàêÂäüÁéá: ${successRate.toFixed(1)}%, Âπ≥ÂùáÂìçÂ∫îÊó∂Èó¥: ${avgResponseTime.toFixed(0)}ms, Âπ≥ÂùáÂêûÂêêÈáè: ${avgThroughput.toFixed(2)}MB/s`);
    });
  });

  // ÊÄßËÉΩÊµãËØïÊÄªÁªì
  afterAll(() => {
    console.log('\nüìä ÊÄßËÉΩÂéãÂäõÊµãËØïÊÄªÁªì:');
    console.log(`- ÂìçÂ∫îÊó∂Èó¥Ê†∑Êú¨Êï∞: ${performanceMetrics.responseTime.length}`);
    console.log(`- ÂêûÂêêÈáèÊ†∑Êú¨Êï∞: ${performanceMetrics.throughput.length}`);
    console.log(`- CPU‰ΩøÁî®ÁéáÊ†∑Êú¨Êï∞: ${performanceMetrics.cpuUsage.length}`);
    console.log(`- ÂÜÖÂ≠ò‰ΩøÁî®Ê†∑Êú¨Êï∞: ${performanceMetrics.memoryUsage.length}`);
    console.log(`- ÈîôËØØÁéáÊ†∑Êú¨Êï∞: ${performanceMetrics.errorRate.length}`);
    console.log(`- Âπ∂ÂèëÂ∫¶Ê†∑Êú¨Êï∞: ${performanceMetrics.concurrency.length}`);

    if (performanceMetrics.responseTime.length > 0) {
      const avgResponseTime = performanceMetrics.responseTime.reduce((a, b) => a + b, 0) / performanceMetrics.responseTime.length;
      console.log(`- Âπ≥ÂùáÂìçÂ∫îÊó∂Èó¥: ${avgResponseTime.toFixed(0)}ms`);
    }

    if (performanceMetrics.throughput.length > 0) {
      const avgThroughput = performanceMetrics.throughput.reduce((a, b) => a + b, 0) / performanceMetrics.throughput.length;
      console.log(`- Âπ≥ÂùáÂêûÂêêÈáè: ${avgThroughput.toFixed(2)}MB/s`);
    }
  });
});