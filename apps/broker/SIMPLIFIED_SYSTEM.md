# Broker系统简化说明

## 简化前后对比

### 原系统复杂度
- **TaskScannerScheduler**: 577行代码，复杂的时间窗口计算，多种重试策略
- **TaskMonitor**: 353行代码，超时检测、失败重试、无数据计数等
- **总代码量**: ~1000行复杂的调度和监控逻辑

### 简化后系统
- **SimpleIntervalScheduler**: 277行代码，严格的间隔时间调度
- **SimpleTaskMonitor**: 58行代码，只监控长时间运行任务
- **总代码量**: ~335行，减少约67%的代码量

## 核心改进

### 1. 时间调度逻辑简化
```typescript
// 原系统：复杂的时间窗口计算
const timeWindows = this.calculateComplexTimeWindows(task, now);
const subTasks = this.createSubTasksWithBatching(timeWindows);

// 简化后：严格按间隔划分
const timeRange = this.calculateTimeRange(task, now);
// startTime, endTime 简单明确
```

### 2. 队列机制替代复杂重试
```typescript
// RabbitMQ配置自动处理：
{
  messageTTL: 30 * 60 * 1000,    // 30分钟超时
  enableDLQ: true,              // 死信队列
  maxRetries: 3,                // 最大重试
}
```

### 3. 状态管理简化
- **原系统**: PENDING, RUNNING, PAUSED, FAILED, TIMEOUT + 复杂转换
- **简化后**: PENDING, RUNNING + 队列处理异常

## 调度行为

### 严格时间间隔
- 每分钟检查所有启用的任务
- 根据任务的 `crawl_interval` 严格计算执行时间
- 时间范围：`previous_time` 到 `current_time`
- 不重叠、不间断的时间序列

### 示例调度流程
```
任务配置:
- start_date: 2025-10-01
- crawl_interval: 1h
- 当前时间: 2025-10-21 10:30

执行流程:
1. 首次执行: 2025-10-01 00:00 → 2025-10-01 01:00
2. 第二次执行: 2025-10-01 01:00 → 2025-10-01 02:00
3. ...
4. 当前执行: 2025-10-21 09:00 → 2025-10-21 10:00
5. 下次执行: 2025-10-21 10:00 → 2025-10-21 11:00
```

## 错误处理策略

### RabbitMQ自动处理
- **超时**: 消息TTL到期自动进入死信队列
- **失败**: 重试3次后进入死信队列
- **队列异常**: 自动重连和恢复

### Broker监控
- 只监控超过2小时运行的任务
- 基本日志记录，不主动干预
- 让队列机制处理大部分异常

## 兼容性保证

### 数据库零修改
- 保持所有现有字段和表结构
- 前端管理界面无需改动
- API接口保持兼容

### 功能保持
- 支持现有的所有任务配置选项
- 支持多账号轮换
- 支持地理位置搜索
- 支持数据聚合功能

## 性能提升

### 减少数据库查询
- 原系统：每分钟多次复杂查询
- 简化后：每分钟单次简单查询

### 减少内存占用
- 移除复杂的重试状态管理
- 移除时间窗口计算缓存
- 简化的任务状态跟踪

### 提升可靠性
- 依赖RabbitMQ的成熟队列机制
- 减少自定义逻辑，降低出错概率
- 清晰的时间边界，避免重复和遗漏

## 监控建议

### 关键指标
1. **队列深度**: 监控 `weibo_crawl_queue` 消息数量
2. **死信队列**: 监控 `weibo_crawl_queue.dlq` 异常消息
3. **任务执行**: 监控调度日志和成功率

### 告警配置
- 死信队列消息数量 > 10
- 任务调度间隔 > 5分钟
- 长时间运行任务 > 2小时

这套简化系统在保持功能完整性的同时，大幅降低了复杂度，提高了系统的可靠性和可维护性。