import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { RawDataSourceService, RawDataSource } from '@pro/mongodb';
import {
  EnhancedRawDataFilter,
  EnhancedRawDataItem,
  EnhancedPaginatedRawData,
  EnhancedStatistics,
  EnhancedTrendDataPoint,
  SourceStatistics,
  RealtimeMetrics,
  SystemHealth,
  DataExportConfig,
  BatchOperationInput,
  BatchOperationResult,
  DataQualityAnalysisConfig,
  DataQualityAnalysisResult,
  AdvancedTimeRangeFilter,
  AggregationGranularity,
  EnhancedProcessingStatus,
  DataQualityLevel,
  DataQualityMetrics,
  ExportFormat,
  BatchOperationType,
  SourceRiskLevel,
  SortDirection
} from './dto/enhanced-raw-data.dto';
import { RawDataDocument, MongoQueryBuilder, TimeFormatter } from './models/raw-data.model';
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

/**
 * 增强的原始数据服务
 * 提供Admin后台所需的高级数据查询、分析、导出和监控功能
 */
@Injectable()
export class EnhancedRawDataService {
  private readonly logger = new Logger(EnhancedRawDataService.name);
  private readonly exportDir = process.env.EXPORT_DIR || '/tmp/exports';
  private readonly maxExportSize = 100000; // 最大导出记录数

  constructor(
    private readonly rawDataSourceService: RawDataSourceService,
    @InjectModel(RawDataSource.name)
    private readonly rawDataModel: Model<RawDataDocument>,
  ) {
    // 确保导出目录存在
    this.ensureExportDirectory();
  }

  /**
   * 获取增强的原始数据列表
   */
  async findEnhancedRawData(filter: EnhancedRawDataFilter): Promise<EnhancedPaginatedRawData> {
    this.logger.log(`查询增强数据，页码: ${filter.page}, 每页: ${filter.pageSize}`);

    const query = this.buildEnhancedQuery(filter);
    const page = filter.page || 1;
    const pageSize = Math.min(filter.pageSize || 20, 200);
    const skip = (page - 1) * pageSize;

    try {
      // 构建聚合管道
      const pipeline = this.buildEnhancedAggregationPipeline(filter, skip, pageSize);
      const [result] = await this.rawDataModel.aggregate(pipeline);

      if (!result) {
        return this.createEmptyPaginatedResponse(page, pageSize);
      }

      const items = await Promise.all(
        result.items.map(doc => this.transformToEnhancedDto(doc))
      );

      const totalPages = Math.ceil(result.total[0]?.count || 0 / pageSize);
      const total = result.total[0]?.count || 0;

      return {
        items,
        total,
        page,
        pageSize,
        totalPages,
        hasNext: page < totalPages,
        hasPrevious: page > 1,
        queryTime: '0',
        suggestions: this.generateQuerySuggestions(filter, total),
        cacheKey: this.generateCacheKey(filter)
      };
    } catch (error) {
      this.logger.error(`查询增强数据失败: ${error.message}`, error.stack);
      throw new Error('查询增强数据时发生错误');
    }
  }

  /**
   * 获取增强的统计信息
   */
  async getEnhancedStatistics(timeRange?: AdvancedTimeRangeFilter): Promise<EnhancedStatistics> {
    this.logger.log('获取增强统计信息');

    try {
      const timeFilter = this.buildTimeFilter(timeRange);
      const pipeline = [
        { $match: timeFilter },
        {
          $group: {
            _id: '$status',
            count: { $sum: 1 },
            avgProcessingTime: { $avg: '$processingDuration' },
            lastUpdate: { $max: '$updatedAt' }
          }
        }
      ];

      const statusStats = await this.rawDataModel.aggregate(pipeline).exec();

      // 构建统计结果
      const stats = this.buildEnhancedStatistics(statusStats);

      // 获取数据源统计
      const sourceStatistics = await this.getSourceStatisticsData(timeFilter);

      // 获取整体质量指标
      const overallQuality = await this.calculateOverallQuality(timeFilter);

      return {
        ...stats,
        sourceStatistics,
        overallQuality,
        timeRange: this.getTimeRangeString(timeRange),
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      this.logger.error(`获取增强统计失败: ${error.message}`, error.stack);
      throw new Error('获取增强统计信息时发生错误');
    }
  }

  /**
   * 获取增强的趋势数据
   */
  async getEnhancedTrendData(
    granularity: AggregationGranularity,
    timeRange?: AdvancedTimeRangeFilter,
    statuses?: EnhancedProcessingStatus[]
  ): Promise<EnhancedTrendDataPoint[]> {
    this.logger.log(`获取增强趋势数据，粒度: ${granularity}`);

    try {
      const pipeline = this.buildEnhancedTrendPipeline(granularity, timeRange, statuses);
      const results = await this.rawDataModel.aggregate(pipeline).exec();

      return results.map(item => ({
        timestamp: item._id,
        count: item.totalCount,
        successful: item.successful || 0,
        failed: item.failed || 0,
        successRate: item.totalCount > 0 ? ((item.successful || 0) / item.totalCount) * 100 : 0,
        avgQualityScore: item.avgQualityScore || 0,
        processingSpeed: item.processingSpeed || 0,
        statusDistribution: JSON.stringify(item.statusDistribution || {})
      }));
    } catch (error) {
      this.logger.error(`获取增强趋势数据失败: ${error.message}`, error.stack);
      throw new Error('获取增强趋势数据时发生错误');
    }
  }

  /**
   * 获取数据源统计信息
   */
  async getSourceStatistics(
    activeOnly: boolean = false,
    riskLevels?: string[]
  ): Promise<SourceStatistics[]> {
    this.logger.log('获取数据源统计信息');

    try {
      const matchStage: any = {};
      if (activeOnly) {
        matchStage.isActive = true;
      }
      if (riskLevels?.length) {
        matchStage.riskLevel = { $in: riskLevels };
      }

      const pipeline = [
        { $match: matchStage },
        {
          $group: {
            _id: {
              sourceType: '$sourceType',
              domain: { $arrayElemAt: [{ $split: ['$sourceUrl', '/'] }, 2] }
            },
            totalData: { $sum: 1 },
            successful: {
              $sum: {
                $cond: [{ $eq: ['$status', 'completed'] }, 1, 0]
              }
            },
            failed: {
              $sum: {
                $cond: [{ $eq: ['$status', 'failed'] }, 1, 0]
              }
            },
            todayNew: {
              $sum: {
                $cond: [
                  {
                    $gte: ['$createdAt', new Date(new Date().setHours(0, 0, 0, 0))]
                  },
                  1,
                  0
                ]
              }
            },
            avgProcessingTime: { $avg: '$processingDuration' },
            lastUpdate: { $max: '$updatedAt' }
          }
        },
        { $sort: { totalData: -1 } }
      ];

      const results = await this.rawDataModel.aggregate(pipeline).exec();

      return Promise.all(
        results.map(async item => {
          const qualityMetrics = await this.calculateSourceQuality(item._id.sourceType, item._id.domain);

          return {
            sourceId: `${item._id.sourceType}_${item._id.domain}`,
            sourceName: `${item._id.sourceType} - ${item._id.domain}`,
            sourceDomain: item._id.domain,
            totalData: item.totalData,
            todayNew: item.todayNew,
            successful: item.successful,
            failed: item.failed,
            successRate: item.totalData > 0 ? (item.successful / item.totalData) * 100 : 0,
            avgProcessingTime: item.avgProcessingTime || 0,
            lastUpdateAt: item.lastUpdate?.toISOString() || new Date().toISOString(),
            riskLevel: this.calculateRiskLevel(item.successful, item.totalData),
            isActive: item.todayNew > 0,
            qualityMetrics
          };
        })
      );
    } catch (error) {
      this.logger.error(`获取数据源统计失败: ${error.message}`, error.stack);
      throw new Error('获取数据源统计信息时发生错误');
    }
  }

  /**
   * 获取实时监控指标
   */
  async getRealtimeMetrics(
    metricNames?: string[],
    timeWindow: number = 24
  ): Promise<RealtimeMetrics[]> {
    this.logger.log(`获取实时指标，时间窗口: ${timeWindow}小时`);

    try {
      const metrics: RealtimeMetrics[] = [];
      const now = new Date();
      const windowStart = new Date(now.getTime() - timeWindow * 60 * 60 * 1000);

      // 处理吞吐量指标
      if (!metricNames || metricNames.includes('throughput')) {
        const throughput = await this.calculateThroughput(windowStart, now);
        metrics.push(throughput);
      }

      // 处理队列长度指标
      if (!metricNames || metricNames.includes('queue_length')) {
        const queueLength = await this.getQueueLength();
        metrics.push(queueLength);
      }

      // 处理错误率指标
      if (!metricNames || metricNames.includes('error_rate')) {
        const errorRate = await this.calculateErrorRate(windowStart, now);
        metrics.push(errorRate);
      }

      // 处理平均响应时间指标
      if (!metricNames || metricNames.includes('response_time')) {
        const responseTime = await this.getAverageResponseTime(windowStart, now);
        metrics.push(responseTime);
      }

      return metrics;
    } catch (error) {
      this.logger.error(`获取实时指标失败: ${error.message}`, error.stack);
      throw new Error('获取实时监控指标时发生错误');
    }
  }

  /**
   * 获取系统健康状态
   */
  async getSystemHealth(): Promise<SystemHealth> {
    this.logger.log('获取系统健康状态');

    try {
      const [
        activeSources,
        pendingData,
        throughput,
        avgResponseTime,
        errorRate,
        systemMetrics
      ] = await Promise.all([
        this.getActiveSourcesCount(),
        this.getPendingDataCount(),
        this.getCurrentThroughput(),
        this.getCurrentResponseTime(),
        this.getCurrentErrorRate(),
        this.getSystemMetrics()
      ]);

      const healthScore = this.calculateHealthScore({
        activeSources,
        pendingData,
        throughput,
        avgResponseTime,
        errorRate,
        systemMetrics
      });

      const status = healthScore >= 80 ? 'healthy' : healthScore >= 60 ? 'warning' : 'critical';
      const activeAlerts = this.generateActiveAlerts({ errorRate, pendingData, systemMetrics });

      return {
        status,
        healthScore,
        activeSources,
        pendingData,
        throughput,
        avgResponseTime,
        errorRate,
        cpuUsage: systemMetrics.cpuUsage,
        memoryUsage: systemMetrics.memoryUsage,
        diskUsage: systemMetrics.diskUsage,
        activeAlerts,
        lastCheckedAt: new Date().toISOString()
      };
    } catch (error) {
      this.logger.error(`获取系统健康状态失败: ${error.message}`, error.stack);
      throw new Error('获取系统健康状态时发生错误');
    }
  }

  /**
   * 分析数据质量
   */
  async analyzeDataQuality(config: DataQualityAnalysisConfig): Promise<DataQualityAnalysisResult> {
    this.logger.log('执行数据质量分析');

    try {
      const analysisId = crypto.randomUUID();
      const query = this.buildEnhancedQuery(config.filter || {});

      // 获取需要分析的数据
      const dataToAnalyze = await this.rawDataModel
        .find(query)
        .limit(10000) // 限制分析数量以保证性能
        .lean()
        .exec();

      // 执行质量分析
      const analysisResult = await this.performQualityAnalysis(dataToAnalyze, config);

      // 生成详细报告
      let detailedReportUrl: string | undefined;
      if (config.detailedReport && config.reportFormat) {
        detailedReportUrl = await this.generateQualityReport(analysisId, analysisResult, config.reportFormat);
      }

      return {
        analysisId,
        timeRange: this.getTimeRangeString(config.filter?.timeRange),
        totalAnalyzed: dataToAnalyze.length,
        overallQuality: analysisResult.overallQuality,
        keyIssues: analysisResult.keyIssues,
        recommendations: analysisResult.recommendations,
        qualityTrend: analysisResult.qualityTrend,
        detailedReportUrl,
        completedAt: new Date().toISOString(),
        nextAnalysisDue: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
      };
    } catch (error) {
      this.logger.error(`数据质量分析失败: ${error.message}`, error.stack);
      throw new Error('数据质量分析时发生错误');
    }
  }

  /**
   * 导出原始数据
   */
  async exportRawData(config: DataExportConfig): Promise<BatchOperationResult> {
    this.logger.log(`开始数据导出，格式: ${config.format}`);

    try {
      const operationId = crypto.randomUUID();
      const startTime = new Date();

      // 验证导出配置
      await this.validateExportConfig(config);

      // 获取要导出的数据
      const query = this.buildEnhancedQuery(config.filter || {});
      const totalCount = await this.rawDataModel.countDocuments(query).exec();

      if (totalCount > this.maxExportSize) {
        throw new BadRequestException(`导出数据量超过限制 (${this.maxExportSize} 条)`);
      }

      const dataToExport = await this.rawDataModel
        .find(query)
        .limit(this.maxExportSize)
        .lean()
        .exec();

      // 执行导出
      const exportFilePath = await this.performExport(dataToExport, config, operationId);

      const endTime = new Date();
      const duration = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);

      return {
        operationType: BatchOperationType.EXPORT,
        totalProcessed: dataToExport.length,
        successful: dataToExport.length,
        failed: 0,
        successRate: 100,
        errors: [],
        startedAt: startTime.toISOString(),
        completedAt: endTime.toISOString(),
        duration,
        operationId,
        exportFileUrl: `/exports/${path.basename(exportFilePath)}`
      };
    } catch (error) {
      this.logger.error(`数据导出失败: ${error.message}`, error.stack);
      throw new Error('数据导出时发生错误');
    }
  }

  /**
   * 执行批量操作
   */
  async executeBatchOperation(input: BatchOperationInput): Promise<BatchOperationResult> {
    this.logger.log(`执行批量操作: ${input.operationType}`);

    try {
      const operationId = crypto.randomUUID();
      const startTime = new Date();

      // 构建查询条件
      const query = input.dataIds.length > 0
        ? { _id: { $in: input.dataIds } }
        : this.buildEnhancedQuery(input.filter || {});

      const totalDocuments = await this.rawDataModel.countDocuments(query).exec();

      if (totalDocuments === 0) {
        throw new BadRequestException('没有找到符合条件的数据');
      }

      // 执行批量操作
      const result = await this.performBatchOperation(query, input);

      const endTime = new Date();
      const duration = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);

      return {
        ...result,
        startedAt: startTime.toISOString(),
        completedAt: endTime.toISOString(),
        duration,
        operationId
      };
    } catch (error) {
      this.logger.error(`批量操作失败: ${error.message}`, error.stack);
      throw new Error('批量操作时发生错误');
    }
  }

  /**
   * 触发质量评估
   */
  async triggerQualityAssessment(
    dataIds?: string[],
    filter?: EnhancedRawDataFilter
  ): Promise<void> {
    this.logger.log('触发质量评估');

    try {
      const query = dataIds?.length
        ? { _id: { $in: dataIds } }
        : this.buildEnhancedQuery(filter || {});

      const documents = await this.rawDataModel.find(query).limit(1000).exec();

      // 为每个文档计算质量指标
      for (const doc of documents) {
        const qualityMetrics = await this.calculateDocumentQuality(doc);
        await this.rawDataModel.updateOne(
          { _id: doc._id },
          { $set: { qualityMetrics, lastQualityAssessed: new Date() } }
        );
      }

      this.logger.log(`质量评估完成，处理了 ${documents.length} 条数据`);
    } catch (error) {
      this.logger.error(`质量评估失败: ${error.message}`, error.stack);
      throw new Error('质量评估时发生错误');
    }
  }

  /**
   * 清理过期数据
   */
  async cleanupExpiredData(
    days: number = 30,
    statuses?: EnhancedProcessingStatus[]
  ): Promise<BatchOperationResult> {
    this.logger.log(`清理过期数据，天数: ${days}`);

    try {
      const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      const targetStatuses = statuses || ['completed', 'archived'];

      const query = {
        status: { $in: targetStatuses },
        updatedAt: { $lt: cutoffDate }
      };

      const result = await this.rawDataModel.deleteMany(query).exec();

      return {
        operationType: BatchOperationType.DELETE,
        totalProcessed: result.deletedCount,
        successful: result.deletedCount,
        failed: 0,
        successRate: 100,
        startedAt: new Date().toISOString(),
        completedAt: new Date().toISOString(),
        duration: 0
      };
    } catch (error) {
      this.logger.error(`清理过期数据失败: ${error.message}`, error.stack);
      throw new Error('清理过期数据时发生错误');
    }
  }

  /**
   * 重建数据索引
   */
  async rebuildDataIndexes(indexTypes?: string[]): Promise<void> {
    this.logger.log(`重建数据索引，类型: ${indexTypes?.join(',') || '全部'}`);

    try {
      const indexes = [
        { sourceType: 1, createdAt: -1 },
        { status: 1, updatedAt: -1 },
        { contentHash: 1 },
        { 'metadata.domain': 1 },
        { qualityMetrics: 'overallScore': -1 },
        { createdAt: -1, status: 1 }
      ];

      // 删除现有索引
      await this.rawDataModel.collection.dropIndexes().catch(() => {});

      // 重建索引
      for (const index of indexes) {
        await this.rawDataModel.collection.createIndex(index);
      }

      this.logger.log('数据索引重建完成');
    } catch (error) {
      this.logger.error(`重建数据索引失败: ${error.message}`, error.stack);
      throw new Error('重建数据索引时发生错误');
    }
  }

  /**
   * 获取数据质量分布
   */
  async getDataQualityDistribution(
    timeRange?: AdvancedTimeRangeFilter,
    groupBy: string = 'sourceType'
  ): Promise<Array<{ quality: DataQualityLevel; count: number; percentage: number }>> {
    this.logger.log('获取数据质量分布');

    try {
      const timeFilter = this.buildTimeFilter(timeRange);
      const pipeline = [
        { $match: timeFilter },
        {
          $group: {
            _id: '$qualityMetrics.level',
            count: { $sum: 1 }
          }
        },
        { $sort: { count: -1 } }
      ];

      const results = await this.rawDataModel.aggregate(pipeline).exec();
      const total = results.reduce((sum, item) => sum + item.count, 0);

      return results.map(item => ({
        quality: item._id || DataQualityLevel.POOR,
        count: item.count,
        percentage: total > 0 ? (item.count / total) * 100 : 0
      }));
    } catch (error) {
      this.logger.error(`获取数据质量分布失败: ${error.message}`, error.stack);
      throw new Error('获取数据质量分布时发生错误');
    }
  }

  /**
   * 获取处理性能指标
   */
  async getProcessingPerformanceMetrics(
    timeRange?: AdvancedTimeRangeFilter
  ): Promise<{
    avgProcessingTime: number;
    throughput: number;
    bottleneckAnalysis: string[];
    optimizationSuggestions: string[];
    performanceTrend: 'improving' | 'stable' | 'degrading';
  }> {
    this.logger.log('获取处理性能指标');

    try {
      const timeFilter = this.buildTimeFilter(timeRange);
      const pipeline = [
        { $match: { ...timeFilter, processingDuration: { $exists: true } } },
        {
          $group: {
            _id: null,
            avgProcessingTime: { $avg: '$processingDuration' },
            maxProcessingTime: { $max: '$processingDuration' },
            minProcessingTime: { $min: '$processingDuration' },
            totalProcessed: { $sum: 1 }
          }
        }
      ];

      const [result] = await this.rawDataModel.aggregate(pipeline).exec();

      const bottleneckAnalysis = await this.analyzeBottlenecks(timeFilter);
      const optimizationSuggestions = this.generateOptimizationSuggestions(result, bottleneckAnalysis);
      const performanceTrend = await this.calculatePerformanceTrend(timeFilter);

      return {
        avgProcessingTime: result?.avgProcessingTime || 0,
        throughput: result?.totalProcessed || 0,
        bottleneckAnalysis,
        optimizationSuggestions,
        performanceTrend
      };
    } catch (error) {
      this.logger.error(`获取处理性能指标失败: ${error.message}`, error.stack);
      throw new Error('获取处理性能指标时发生错误');
    }
  }

  /**
   * 订阅原始数据更新
   */
  async subscribeToRawDataUpdates(filter?: EnhancedRawDataFilter) {
    // 实现WebSocket订阅逻辑
    // 这里返回一个AsyncIterator或其他兼容GraphQL Subscription的类型
    throw new Error('实时订阅功能待实现');
  }

  /**
   * 订阅系统健康状态更新
   */
  async subscribeToSystemHealth() {
    // 实现WebSocket订阅逻辑
    // 这里返回一个AsyncIterator或其他兼容GraphQL Subscription的类型
    throw new Error('实时订阅功能待实现');
  }

  // 私有辅助方法

  private ensureExportDirectory(): void {
    if (!fs.existsSync(this.exportDir)) {
      fs.mkdirSync(this.exportDir, { recursive: true });
    }
  }

  private buildEnhancedQuery(filter: EnhancedRawDataFilter): any {
    const query: any = {};

    if (filter.keyword) {
      query.$or = [
        { sourceUrl: { $regex: filter.keyword, $options: 'i' } },
        { rawContent: { $regex: filter.keyword, $options: 'i' } },
        { 'metadata.title': { $regex: filter.keyword, $options: 'i' } }
      ];
    }

    if (filter.statuses?.length) {
      query.status = { $in: filter.statuses };
    }

    if (filter.qualityLevels?.length) {
      query['qualityMetrics.level'] = { $in: filter.qualityLevels };
    }

    if (filter.contentHash) {
      query.contentHash = filter.contentHash;
    }

    if (!filter.includeArchived) {
      query.status = { $ne: 'archived' };
    }

    // 添加时间范围过滤
    const timeFilter = this.buildTimeFilter(filter.timeRange);
    Object.assign(query, timeFilter);

    return query;
  }

  private buildTimeFilter(timeRange?: AdvancedTimeRangeFilter): any {
    if (!timeRange) return {};

    const filter: any = {};
    if (timeRange.startDate || timeRange.endDate) {
      filter.createdAt = {};
      if (timeRange.startDate) {
        filter.createdAt.$gte = new Date(timeRange.startDate);
      }
      if (timeRange.endDate) {
        filter.createdAt.$lte = new Date(timeRange.endDate);
      }
    }

    return filter;
  }

  private buildEnhancedAggregationPipeline(
    filter: EnhancedRawDataFilter,
    skip: number,
    limit: number
  ): any[] {
    const matchStage = this.buildEnhancedQuery(filter);

    // 添加排序
    const sortStage: any = {};
    if (filter.sortBy?.length) {
      filter.sortBy.forEach(sort => {
        sortStage[sort.field] = sort.direction === SortDirection.ASC ? 1 : -1;
      });
    } else {
      sortStage.createdAt = -1; // 默认按创建时间倒序
    }

    return [
      { $match: matchStage },
      { $sort: sortStage },
      {
        $facet: {
          items: [
            { $skip: skip },
            { $limit: limit }
          ],
          total: [
            { $count: 'count' }
          ]
        }
      }
    ];
  }

  private async transformToEnhancedDto(document: any): Promise<EnhancedRawDataItem> {
    const qualityMetrics = await this.calculateDocumentQuality(document);
    const sourceDomain = this.extractDomain(document.sourceUrl);

    return {
      _id: document._id.toString(),
      sourceType: document.sourceType,
      sourceUrl: document.sourceUrl,
      contentPreview: this.generateContentPreview(document.rawContent),
      contentHash: document.contentHash,
      status: document.status,
      errorMessage: document.errorMessage,
      createdAt: TimeFormatter.toISOString(document.createdAt),
      processedAt: document.processedAt ? TimeFormatter.toISOString(document.processedAt) : undefined,
      metadata: JSON.stringify(document.metadata || {}),
      qualityMetrics,
      sourceDomain,
      sourceRiskLevel: this.calculateRiskLevelForSource(sourceDomain),
      contentLength: document.rawContent?.length || 0,
      retryCount: document.retryCount || 0,
      estimatedProcessingTime: this.estimateProcessingTime(document),
      relatedDataIds: document.relatedDataIds || [],
      priority: this.calculatePriority(document)
    };
  }

  private async calculateDocumentQuality(document: any): Promise<DataQualityMetrics> {
    // 实现文档质量计算逻辑
    const completeness = this.calculateCompleteness(document);
    const accuracy = this.calculateAccuracy(document);
    const consistency = this.calculateConsistency(document);
    const timeliness = this.calculateTimeliness(document);
    const validity = this.calculateValidity(document);

    const overallScore = (completeness + accuracy + consistency + timeliness + validity) / 5;
    const level = this.getQualityLevel(overallScore);

    return {
      level,
      completenessScore: completeness,
      accuracyScore: accuracy,
      consistencyScore: consistency,
      timelinessScore: timeliness,
      validityScore: validity,
      overallScore,
      issues: this.identifyQualityIssues(document),
      recommendations: this.generateQualityRecommendations(document, overallScore),
      lastAssessedAt: new Date().toISOString()
    };
  }

  private calculateCompleteness(document: any): number {
    const requiredFields = ['sourceUrl', 'rawContent', 'contentHash'];
    const presentFields = requiredFields.filter(field => document[field]);
    return (presentFields.length / requiredFields.length) * 100;
  }

  private calculateAccuracy(document: any): number {
    // 实现准确性计算逻辑
    // 这里可以基于数据验证规则、格式检查等
    return 85; // 示例值
  }

  private calculateConsistency(document: any): number {
    // 实现一致性计算逻辑
    return 90; // 示例值
  }

  private calculateTimeliness(document: any): number {
    const ageInHours = (Date.now() - new Date(document.createdAt).getTime()) / (1000 * 60 * 60);
    if (ageInHours < 1) return 100;
    if (ageInHours < 24) return 90;
    if (ageInHours < 168) return 70;
    return 50;
  }

  private calculateValidity(document: any): number {
    // 实现有效性计算逻辑
    // 检查URL格式、内容格式等
    return document.sourceUrl && this.isValidUrl(document.sourceUrl) ? 95 : 50;
  }

  private getQualityLevel(score: number): DataQualityLevel {
    if (score >= 90) return DataQualityLevel.EXCELLENT;
    if (score >= 75) return DataQualityLevel.GOOD;
    if (score >= 60) return DataQualityLevel.FAIR;
    if (score >= 40) return DataQualityLevel.POOR;
    return DataQualityLevel.CRITICAL;
  }

  private identifyQualityIssues(document: any): string[] {
    const issues: string[] = [];

    if (!document.sourceUrl) issues.push('缺少源URL');
    if (!document.rawContent) issues.push('缺少原始内容');
    if (!document.contentHash) issues.push('缺少内容哈希');
    if (document.rawContent && document.rawContent.length < 50) {
      issues.push('内容过短');
    }

    return issues;
  }

  private generateQualityRecommendations(document: any, score: number): string[] {
    const recommendations: string[] = [];

    if (score < 70) {
      recommendations.push('建议重新获取或补充数据');
    }
    if (!document.metadata || Object.keys(document.metadata).length === 0) {
      recommendations.push('建议添加更多元数据信息');
    }

    return recommendations;
  }

  private extractDomain(url: string): string {
    try {
      return new URL(url).hostname;
    } catch {
      return 'unknown';
    }
  }

  private calculateRiskLevel(successful: number, total: number): SourceRiskLevel {
    const successRate = total > 0 ? successful / total : 0;

    if (successRate >= 0.95) return SourceRiskLevel.LOW;
    if (successRate >= 0.85) return SourceRiskLevel.MEDIUM;
    if (successRate >= 0.70) return SourceRiskLevel.HIGH;
    return SourceRiskLevel.CRITICAL;
  }

  private calculateRiskLevelForSource(domain: string): SourceRiskLevel {
    // 实现基于域名的风险等级计算
    const trustedDomains = ['weibo.com', 'jd.com', 'tmall.com'];
    return trustedDomains.includes(domain) ? SourceRiskLevel.LOW : SourceRiskLevel.MEDIUM;
  }

  private generateContentPreview(content: string, maxLength: number = 200): string {
    if (!content) return '';
    const cleaned = content.replace(/\s+/g, ' ').trim();
    return cleaned.length > maxLength ? cleaned.substring(0, maxLength) + '...' : cleaned;
  }

  private estimateProcessingTime(document: any): string {
    const contentLength = document.rawContent?.length || 0;
    const estimatedSeconds = Math.max(1, contentLength / 1000);
    return `${estimatedSeconds}秒`;
  }

  private calculatePriority(document: any): 'low' | 'medium' | 'high' | 'urgent' {
    if (document.status === 'failed') return 'high';
    if (document.sourceType === 'weibo') return 'medium';
    return 'low';
  }

  private isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  private generateQuerySuggestions(filter: EnhancedRawDataFilter, total: number): string[] {
    const suggestions: string[] = [];

    if (total === 0) {
      suggestions.push('尝试放宽过滤条件');
      suggestions.push('检查时间范围设置');
    } else if (total > 10000) {
      suggestions.push('建议使用更具体的过滤条件');
      suggestions.push('考虑缩小时间范围');
    }

    return suggestions;
  }

  private generateCacheKey(filter: EnhancedRawDataFilter): string {
    const keyData = JSON.stringify(filter);
    return crypto.createHash('md5').update(keyData).digest('hex');
  }

  private createEmptyPaginatedResponse(page: number, pageSize: number): EnhancedPaginatedRawData {
    return {
      items: [],
      total: 0,
      page,
      pageSize,
      totalPages: 0,
      hasNext: false,
      hasPrevious: false,
      queryTime: '0',
      suggestions: ['没有找到符合条件的数据'],
      cacheKey: ''
    };
  }

  private buildEnhancedStatistics(statusStats: any[]): Partial<EnhancedStatistics> {
    const stats: any = {
      pending: 0,
      processing: 0,
      completed: 0,
      failed: 0,
      retrying: 0,
      cancelled: 0,
      archived: 0,
      total: 0,
      avgProcessingTime: 0
    };

    statusStats.forEach(item => {
      stats[item._id] = item.count;
      stats.total += item.count;
    });

    stats.successRate = stats.total > 0 ? (stats.completed / stats.total) * 100 : 0;
    stats.todayThroughput = await this.calculateTodayThroughput();

    return stats;
  }

  private buildEnhancedTrendPipeline(
    granularity: AggregationGranularity,
    timeRange?: AdvancedTimeRangeFilter,
    statuses?: EnhancedProcessingStatus[]
  ): any[] {
    const pipeline: any[] = [];

    // 匹配阶段
    const matchStage: any = this.buildTimeFilter(timeRange);
    if (statuses?.length) {
      matchStage.status = { $in: statuses };
    }
    pipeline.push({ $match: matchStage });

    // 时间分组阶段
    const dateFormat = this.getDateFormat(granularity);
    pipeline.push({
      $group: {
        _id: {
          $dateToString: {
            format: dateFormat,
            date: '$createdAt'
          }
        },
        totalCount: { $sum: 1 },
        successful: {
          $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] }
        },
        failed: {
          $sum: { $cond: [{ $eq: ['$status', 'failed'] }, 1, 0] }
        },
        avgQualityScore: { $avg: '$qualityMetrics.overallScore' },
        processingSpeed: { $avg: '$processingSpeed' },
        statusDistribution: { $push: '$status' }
      }
    });

    pipeline.push({ $sort: { '_id': 1 } });

    return pipeline;
  }

  private getDateFormat(granularity: AggregationGranularity): string {
    switch (granularity) {
      case AggregationGranularity.MINUTE:
        return '%Y-%m-%d %H:%M:00';
      case AggregationGranularity.HOUR:
        return '%Y-%m-%d %H:00:00';
      case AggregationGranularity.DAY:
        return '%Y-%m-%d';
      case AggregationGranularity.WEEK:
        return '%Y-%U';
      case AggregationGranularity.MONTH:
        return '%Y-%m';
      case AggregationGranularity.QUARTER:
        return '%Y-%q';
      case AggregationGranularity.YEAR:
        return '%Y';
      default:
        return '%Y-%m-%d';
    }
  }

  private getTimeRangeString(timeRange?: AdvancedTimeRangeFilter): string {
    if (!timeRange) return '全部时间';
    const start = timeRange.startDate || '起始';
    const end = timeRange.endDate || '现在';
    return `${start} 至 ${end}`;
  }

  // 更多私有方法的实现...
  // 由于篇幅限制，这里只展示了部分核心方法的实现
  // 完整实现需要包含所有辅助方法的完整逻辑

  private async calculateSourceQuality(sourceType: string, domain: string): Promise<DataQualityMetrics> {
    // 实现数据源质量计算逻辑
    return {
      level: DataQualityLevel.GOOD,
      completenessScore: 85,
      accuracyScore: 90,
      consistencyScore: 88,
      timelinessScore: 92,
      validityScore: 87,
      overallScore: 88.4,
      issues: [],
      recommendations: [],
      lastAssessedAt: new Date().toISOString()
    };
  }

  private async calculateOverallQuality(timeFilter?: any): Promise<DataQualityMetrics> {
    // 实现整体质量计算逻辑
    return {
      level: DataQualityLevel.GOOD,
      completenessScore: 80,
      accuracyScore: 85,
      consistencyScore: 82,
      timelinessScore: 88,
      validityScore: 83,
      overallScore: 83.6,
      issues: ['部分数据缺少元信息'],
      recommendations: ['建议完善元数据收集'],
      lastAssessedAt: new Date().toISOString()
    };
  }

  private async getSourceStatisticsData(timeFilter?: any): Promise<SourceStatistics[]> {
    // 实现数据源统计逻辑
    return [];
  }

  private async calculateThroughput(startDate: Date, endDate: Date): Promise<RealtimeMetrics> {
    const count = await this.rawDataModel.countDocuments({
      createdAt: { $gte: startDate, $lte: endDate }
    });

    const hours = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60);
    const currentValue = count / hours;

    return {
      name: 'throughput',
      currentValue,
      changeRate: 5.2,
      trend: 'up',
      unit: '条/小时',
      lastUpdated: new Date().toISOString(),
      historicalData: [currentValue],
      isAlerting: false
    };
  }

  private async getQueueLength(): Promise<RealtimeMetrics> {
    const count = await this.rawDataModel.countDocuments({
      status: { $in: ['pending', 'processing'] }
    });

    return {
      name: 'queue_length',
      currentValue: count,
      changeRate: -2.1,
      trend: 'down',
      unit: '条',
      lastUpdated: new Date().toISOString(),
      historicalData: [count],
      upperThreshold: 1000,
      isAlerting: count > 1000
    };
  }

  private async calculateErrorRate(startDate: Date, endDate: Date): Promise<RealtimeMetrics> {
    const [total, failed] = await Promise.all([
      this.rawDataModel.countDocuments({
        createdAt: { $gte: startDate, $lte: endDate }
      }),
      this.rawDataModel.countDocuments({
        createdAt: { $gte: startDate, $lte: endDate },
        status: 'failed'
      })
    ]);

    const currentValue = total > 0 ? (failed / total) * 100 : 0;

    return {
      name: 'error_rate',
      currentValue,
      changeRate: 1.5,
      trend: 'up',
      unit: '%',
      lastUpdated: new Date().toISOString(),
      historicalData: [currentValue],
      upperThreshold: 5.0,
      isAlerting: currentValue > 5.0
    };
  }

  private async getAverageResponseTime(startDate: Date, endDate: Date): Promise<RealtimeMetrics> {
    const [result] = await this.rawDataModel.aggregate([
      {
        $match: {
          createdAt: { $gte: startDate, $lte: endDate },
          processingDuration: { $exists: true }
        }
      },
      {
        $group: {
          _id: null,
          avgDuration: { $avg: '$processingDuration' }
        }
      }
    ]).exec();

    const currentValue = result?.avgDuration || 0;

    return {
      name: 'response_time',
      currentValue,
      changeRate: -3.2,
      trend: 'down',
      unit: '秒',
      lastUpdated: new Date().toISOString(),
      historicalData: [currentValue],
      upperThreshold: 10.0,
      isAlerting: currentValue > 10.0
    };
  }

  private async getActiveSourcesCount(): Promise<number> {
    const result = await this.rawDataModel.aggregate([
      {
        $group: {
          _id: '$sourceType',
          lastUpdate: { $max: '$updatedAt' }
        }
      },
      {
        $match: {
          lastUpdate: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
        }
      }
    ]).exec();

    return result.length;
  }

  private async getPendingDataCount(): Promise<number> {
    return await this.rawDataModel.countDocuments({
      status: { $in: ['pending', 'processing'] }
    });
  }

  private async getCurrentThroughput(): Promise<number> {
    const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
    const count = await this.rawDataModel.countDocuments({
      createdAt: { $gte: hourAgo },
      status: 'completed'
    });
    return count;
  }

  private async getCurrentResponseTime(): Promise<number> {
    const [result] = await this.rawDataModel.aggregate([
      {
        $match: {
          updatedAt: { $gte: new Date(Date.now() - 60 * 60 * 1000) },
          processingDuration: { $exists: true }
        }
      },
      {
        $group: {
          _id: null,
          avgDuration: { $avg: '$processingDuration' }
        }
      }
    ]).exec();

    return result?.avgDuration || 0;
  }

  private async getCurrentErrorRate(): Promise<number> {
    const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
    const [total, failed] = await Promise.all([
      this.rawDataModel.countDocuments({ createdAt: { $gte: hourAgo } }),
      this.rawDataModel.countDocuments({
        createdAt: { $gte: hourAgo },
        status: 'failed'
      })
    ]);

    return total > 0 ? (failed / total) * 100 : 0;
  }

  private async getSystemMetrics(): Promise<{
    cpuUsage: string;
    memoryUsage: string;
    diskUsage: string;
  }> {
    // 实现系统指标获取逻辑
    // 这里应该调用系统监控服务获取真实的系统指标
    return {
      cpuUsage: '45%',
      memoryUsage: '67%',
      diskUsage: '32%'
    };
  }

  private calculateHealthScore(metrics: any): number {
    let score = 100;

    // 基于错误率扣分
    if (metrics.errorRate > 10) score -= 30;
    else if (metrics.errorRate > 5) score -= 15;
    else if (metrics.errorRate > 2) score -= 5;

    // 基于响应时间扣分
    if (metrics.avgResponseTime > 10) score -= 20;
    else if (metrics.avgResponseTime > 5) score -= 10;

    // 基于积压数据扣分
    if (metrics.pendingData > 5000) score -= 25;
    else if (metrics.pendingData > 1000) score -= 10;

    return Math.max(0, score);
  }

  private generateActiveAlerts(metrics: any): string[] {
    const alerts: string[] = [];

    if (metrics.errorRate > 5) {
      alerts.push(`错误率过高: ${metrics.errorRate.toFixed(1)}%`);
    }

    if (metrics.pendingData > 1000) {
      alerts.push(`数据积压严重: ${metrics.pendingData} 条待处理`);
    }

    if (metrics.avgResponseTime > 5) {
      alerts.push(`响应时间过长: ${metrics.avgResponseTime.toFixed(1)}秒`);
    }

    return alerts;
  }

  private async performQualityAnalysis(
    data: any[],
    config: DataQualityAnalysisConfig
  ): Promise<any> {
    // 实现详细的质量分析逻辑
    const overallQuality = await this.calculateOverallQuality();

    return {
      overallQuality,
      keyIssues: ['数据完整性有待提升', '部分源响应时间过长'],
      recommendations: ['优化数据获取流程', '增加数据验证机制'],
      qualityTrend: 2.5
    };
  }

  private async generateQualityReport(
    analysisId: string,
    result: any,
    format: ExportFormat
  ): Promise<string> {
    // 实现报告生成逻辑
    const filename = `quality_report_${analysisId}.${format}`;
    const filepath = path.join(this.exportDir, filename);

    // 根据格式生成报告
    // 这里应该实现具体的报告生成逻辑

    return filepath;
  }

  private async validateExportConfig(config: DataExportConfig): Promise<void> {
    if (!config.format) {
      throw new BadRequestException('导出格式不能为空');
    }

    if (config.chunkSize && config.chunkSize > 50000) {
      throw new BadRequestException('分片大小不能超过50000条');
    }
  }

  private async performExport(
    data: any[],
    config: DataExportConfig,
    operationId: string
  ): Promise<string> {
    const filename = config.filename || `export_${operationId}.${config.format}`;
    const filepath = path.join(this.exportDir, filename);

    // 根据格式执行导出
    switch (config.format) {
      case ExportFormat.JSON:
        await this.exportToJson(data, filepath, config);
        break;
      case ExportFormat.CSV:
        await this.exportToCsv(data, filepath, config);
        break;
      // 实现其他格式
      default:
        throw new BadRequestException(`不支持的导出格式: ${config.format}`);
    }

    return filepath;
  }

  private async exportToJson(data: any[], filepath: string, config: DataExportConfig): Promise<void> {
    const jsonData = data.map(item => {
      const exported: any = {
        _id: item._id,
        sourceType: item.sourceType,
        sourceUrl: item.sourceUrl,
        contentPreview: item.contentPreview,
        status: item.status,
        createdAt: item.createdAt
      };

      // 包含指定字段
      if (config.fields?.length) {
        config.fields.forEach(field => {
          if (item[field] !== undefined) {
            exported[field] = item[field];
          }
        });
      }

      return exported;
    });

    fs.writeFileSync(filepath, JSON.stringify(jsonData, null, 2), 'utf8');
  }

  private async exportToCsv(data: any[], filepath: string, config: DataExportConfig): Promise<void> {
    // 实现CSV导出逻辑
    // 这里应该使用CSV库来生成CSV文件
    throw new Error('CSV导出功能待实现');
  }

  private async performBatchOperation(
    query: any,
    input: BatchOperationInput
  ): Promise<Omit<BatchOperationResult, 'startedAt' | 'completedAt' | 'duration' | 'operationId'>> {
    const batchSize = input.batchSize || 1000;
    let successful = 0;
    let failed = 0;
    const errors: string[] = [];

    try {
      switch (input.operationType) {
        case BatchOperationType.RETRY:
          const retryResult = await this.rawDataModel.updateMany(
            { ...query, status: 'failed' },
            { $set: { status: 'pending', errorMessage: null } }
          );
          successful = retryResult.modifiedCount;
          break;

        case BatchOperationType.CANCEL:
          const cancelResult = await this.rawDataModel.updateMany(
            { ...query, status: { $in: ['pending', 'processing'] } },
            { $set: { status: 'cancelled' } }
          );
          successful = cancelResult.modifiedCount;
          break;

        case BatchOperationType.ARCHIVE:
          const archiveResult = await this.rawDataModel.updateMany(
            { ...query, status: 'completed' },
            { $set: { status: 'archived' } }
          );
          successful = archiveResult.modifiedCount;
          break;

        case BatchOperationType.DELETE:
          const deleteResult = await this.rawDataModel.deleteMany(query);
          successful = deleteResult.deletedCount;
          break;

        case BatchOperationType.UPDATE_STATUS:
          if (!input.targetStatus) {
            throw new BadRequestException('状态更新操作必须指定目标状态');
          }
          const updateResult = await this.rawDataModel.updateMany(
            query,
            { $set: { status: input.targetStatus } }
          );
          successful = updateResult.modifiedCount;
          break;

        default:
          throw new BadRequestException(`不支持的批量操作类型: ${input.operationType}`);
      }
    } catch (error) {
      failed = 1;
      errors.push(error.message);
    }

    const totalProcessed = successful + failed;

    return {
      operationType: input.operationType,
      totalProcessed,
      successful,
      failed,
      successRate: totalProcessed > 0 ? (successful / totalProcessed) * 100 : 0,
      errors
    };
  }

  private async calculateTodayThroughput(): Promise<number> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    return await this.rawDataModel.countDocuments({
      createdAt: { $gte: today },
      status: 'completed'
    });
  }

  private async analyzeBottlenecks(timeFilter: any): Promise<string[]> {
    const bottlenecks: string[] = [];

    // 分析处理时间瓶颈
    const slowProcessing = await this.rawDataModel.countDocuments({
      ...timeFilter,
      processingDuration: { $gt: 30000 } // 超过30秒
    });

    if (slowProcessing > 100) {
      bottlenecks.push('存在大量处理时间过长的数据');
    }

    // 分析失败率瓶颈
    const failureRate = await this.calculateFailureRate(timeFilter);
    if (failureRate > 10) {
      bottlenecks.push('数据失败率过高');
    }

    return bottlenecks;
  }

  private async calculateFailureRate(timeFilter: any): Promise<number> {
    const [total, failed] = await Promise.all([
      this.rawDataModel.countDocuments(timeFilter),
      this.rawDataModel.countDocuments({ ...timeFilter, status: 'failed' })
    ]);

    return total > 0 ? (failed / total) * 100 : 0;
  }

  private generateOptimizationSuggestions(
    performanceData: any,
    bottlenecks: string[]
  ): string[] {
    const suggestions: string[] = [];

    if (bottlenecks.includes('存在大量处理时间过长的数据')) {
      suggestions.push('优化处理算法，减少单条数据处理时间');
      suggestions.push('考虑增加处理节点数量');
    }

    if (bottlenecks.includes('数据失败率过高')) {
      suggestions.push('增强错误处理和重试机制');
      suggestions.push('改进数据源验证逻辑');
    }

    if (performanceData.avgProcessingTime > 10000) {
      suggestions.push('优化数据库查询性能');
    }

    return suggestions;
  }

  private async calculatePerformanceTrend(timeFilter: any): Promise<'improving' | 'stable' | 'degrading'> {
    // 实现性能趋势计算逻辑
    // 比较当前时间段与前一段时间的性能指标
    return 'stable';
  }
}